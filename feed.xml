<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <generator uri="https://blog.rust-lang.org/" version="0.1.0">Rust Blog</generator>
    <link href="https://blog.rust-lang.org/feed.xml" rel="self" type="application/atom+xml" />
    <link href="https://blog.rust-lang.org/" rel="alternate" type="text/html" />
    <id>https://blog.rust-lang.org/</id>
    <title>Rust Blog</title>
    <subtitle>Empowering everyone to build reliable and efficient software.</subtitle>
    <author>
        <name>Maintained by the Rust Teams.</name>
        <uri>https://github.com/rust-lang/blog.rust-lang.org/</uri>
    </author>
    <updated>2022-06-29T07:14:52+00:00</updated>

    
    <entry>
        <title>Announcing The RustConf PostConf UnConf</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/06/28/rust-unconference.html" type="text/html" title="Announcing The RustConf PostConf UnConf" />
        <published>2022-06-28T00:00:00+00:00</published>
        <updated>2022-06-28T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/06/28/rust-unconference.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/06/28/rust-unconference.html">&lt;p&gt;Hello Rust community!&lt;/p&gt;
&lt;p&gt;We&#x27;re excited to announce that the Rust project teams will be hosting an
unconference&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn1&quot; id&#x3D;&quot;fnref1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; the day after &lt;a href&#x3D;&quot;https://rustconf.com&quot;&gt;RustConf&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src&#x3D;&quot;../../../images/2022-06-28-rust-unconference/Eventbrite_Unconf.jpg&quot; alt&#x3D;&quot;RustConf PostConf UnConf promo image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The PostConf Unconf will be dedicated to the Rust project and will be a
fantastic opportunity for users, contributors, and maintainers to network and
discuss the project&#x27;s development.&lt;/p&gt;
&lt;p&gt;There will be no set agenda; instead, attendees will decide what will be
discussed together and can move freely between sessions to find ones in which
they can contribute most effectively based on their individual interests and
needs.&lt;/p&gt;
&lt;p&gt;To get the most out of the unconference, jot down your thoughts ahead of time
and bring them ready to share. We will also set up a channel in the RustConf
Discord for folks to communicate and make preliminary, informal plans.&lt;/p&gt;
&lt;p&gt;If you plan to attend, please register as soon as possible to help us plan
appropriately. If we run out of space, project participants will be given preference.
Registration is free and open to everyone attending RustConf.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href&#x3D;&quot;https://www.eventbrite.com/e/rustconf-postconf-unconf-registration-373057423797&quot;&gt;ðŸš¨Register Now!ðŸš¨&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;We hope to see you there!&lt;/p&gt;
&lt;section class&#x3D;&quot;footnotes&quot;&gt;
&lt;ol&gt;
&lt;li id&#x3D;&quot;fn1&quot;&gt;
&lt;p&gt;If you are unfamiliar with the notion of an unconference, you may find &lt;a href&#x3D;&quot;https://universityinnovation.org/wiki/Resource:How_to_organize_an_unconference&quot;&gt;this informational piece helpful&lt;/a&gt;. &lt;a href&#x3D;&quot;#fnref1&quot; class&#x3D;&quot;footnote-backref&quot;&gt;â†©&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</content>

        <author>
            <name>Jane Lusby, on behalf of The Rust Project Teams</name>
        </author>
    </entry>
    
    <entry>
        <title>Call for testing: Cargo sparse-registry</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/06/22/sparse-registry-testing.html" type="text/html" title="Call for testing: Cargo sparse-registry" />
        <published>2022-06-22T00:00:00+00:00</published>
        <updated>2022-06-22T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/06/22/sparse-registry-testing.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/06/22/sparse-registry-testing.html">&lt;p&gt;The Cargo nightly &lt;a href&#x3D;&quot;https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#sparse-registry&quot;&gt;&lt;code&gt;sparse-registry&lt;/code&gt;&lt;/a&gt; feature is ready for testing. The
feature causes Cargo to access the crates.io index over HTTP, rather than git. It can
provide a significant performance improvement, especially if the local copy of
the git index is out-of-date or not yet cloned.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#overview&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;
&lt;p&gt;To try it out, add the &lt;code&gt;-Z sparse-registry&lt;/code&gt; flag on a recent nightly build of Cargo.
For example, to update dependencies:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rustup update nightly
cargo +nightly -Z sparse-registry update
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The feature can also be enabled by setting the environment variable
&lt;code&gt;CARGO_UNSTABLE_SPARSE_REGISTRY&#x3D;true&lt;/code&gt;. Setting this variable will have no effect on stable
Cargo, making it easy to opt-in for CI jobs.&lt;/p&gt;
&lt;p&gt;The minimum Cargo version is &lt;code&gt;cargo 2022-06-17&lt;/code&gt;, which is bundled with &lt;code&gt;rustc 2022-06-20&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;You can &lt;a href&#x3D;&quot;https://internals.rust-lang.org/t/call-for-testing-cargo-sparse-registry/16862&quot;&gt;leave feedback on the internals thread&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you see any issues &lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo/issues&quot;&gt;please report them on the Cargo repo&lt;/a&gt;. The output of Cargo
with the environment variable &lt;code&gt;CARGO_LOG&#x3D;cargo::sources::registry::http_remote&#x3D;trace&lt;/code&gt; set
will be helpful in debugging.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#details&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;details&quot;&gt;&lt;/a&gt;Details&lt;/h2&gt;
&lt;p&gt;Accessing the index over HTTP allows crates.io to continue growing without hampering
performance. The current git index continues to grow as new crates are published,
and clients must download the entire index. The HTTP index only requires downloading
metadata for crates in your dependency tree.&lt;/p&gt;
&lt;p&gt;The performance improvement for clients should be especially noticeable in CI
environments, particularly if no local cache of the index exists.&lt;/p&gt;
&lt;p&gt;On the server side, the HTTP protocol is much simpler to cache on a CDN, which improves
scalability and reduces server load. Due to this caching, crate updates may take an
extra minute to appear in the index.&lt;/p&gt;
&lt;p&gt;The Cargo team plans to eventually make this the default way to access crates.io
(though the git index will remain for compatibility with older versions of Cargo and
external tools). &lt;code&gt;Cargo.lock&lt;/code&gt; files will continue to reference the existing crates.io
index on GitHub to avoid churn.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;-Z sparse-registry&lt;/code&gt; flag also enables alternative registries to be accessed over
HTTP. For more details, see the &lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo/issues/9069&quot;&gt;tracking issue&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#thank-you&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;thank-you&quot;&gt;&lt;/a&gt;Thank you&lt;/h2&gt;
&lt;p&gt;This project has been in the works for over 2.5 years with collaboration from the crates.io,
infra, and Cargo teams.&lt;/p&gt;
&lt;p&gt;&lt;a href&#x3D;&quot;https://github.com/kornelski&quot;&gt;@kornelski&lt;/a&gt; wrote the &lt;a href&#x3D;&quot;https://rust-lang.github.io/rfcs/2789-sparse-index.html&quot;&gt;sparse-index RFC&lt;/a&gt; and initial
performance proof of concept. &lt;a href&#x3D;&quot;https://github.com/jonhoo&quot;&gt;@jonhoo&lt;/a&gt; created the initial
implementation in Cargo and gathered performance data. &lt;a href&#x3D;&quot;https://github.com/arlosi&quot;&gt;@arlosi&lt;/a&gt;
completed the implementation in Cargo and implemented the changes to crates.io to serve the
index. &lt;a href&#x3D;&quot;https://github.com/eh2406&quot;&gt;@eh2406&lt;/a&gt; provided numerous reviews and feedback to get
all the changes landed. Many others from the community helped by providing suggestions,
feedback, and testing.&lt;/p&gt;
&lt;p&gt;Thank you to everyone involved!&lt;/p&gt;
</content>

        <author>
            <name>Arlo Siemsen</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.61.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/05/19/Rust-1.61.0.html" type="text/html" title="Announcing Rust 1.61.0" />
        <published>2022-05-19T00:00:00+00:00</published>
        <updated>2022-05-19T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/05/19/Rust-1.61.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/05/19/Rust-1.61.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.61.0. Rust is a programming language
empowering everyone to build reliable and efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, you can get 1.61.0 with:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-console&quot;&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt;
from the appropriate page on our website, and check out the
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1610-2022-05-19&quot;&gt;detailed release notes for 1.61.0&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;p&gt;If you&#x27;d like to help us out by testing future releases, you might consider updating locally to use
the beta channel (&lt;code&gt;rustup default beta&lt;/code&gt;) or the nightly channel (&lt;code&gt;rustup default nightly&lt;/code&gt;).
Please &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/new/choose&quot;&gt;report&lt;/a&gt; any bugs you might come across!&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-in-1610-stable&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-in-1610-stable&quot;&gt;&lt;/a&gt;What&#x27;s in 1.61.0 stable&lt;/h2&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#custom-exit-codes-from-main&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;custom-exit-codes-from-main&quot;&gt;&lt;/a&gt;Custom exit codes from &lt;code&gt;main&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;In the beginning, Rust &lt;code&gt;main&lt;/code&gt; functions could only return the unit type &lt;code&gt;()&lt;/code&gt; (either implicitly or explicitly), always indicating success
in the exit status, and if you wanted otherwise you had to call &lt;code&gt;process::exit(code)&lt;/code&gt;. Since Rust
1.26, &lt;code&gt;main&lt;/code&gt; has been allowed to return a &lt;code&gt;Result&lt;/code&gt;, where &lt;code&gt;Ok&lt;/code&gt; translated to a C &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; and
&lt;code&gt;Err&lt;/code&gt; to &lt;code&gt;EXIT_FAILURE&lt;/code&gt; (also debug-printing the error). Under the hood, these alternate return
types were unified by an unstable &lt;code&gt;Termination&lt;/code&gt; trait.&lt;/p&gt;
&lt;p&gt;In this release, that &lt;code&gt;Termination&lt;/code&gt; trait is finally stable, along with a more general &lt;code&gt;ExitCode&lt;/code&gt;
type that wraps platform-specific return types. That has &lt;code&gt;SUCCESS&lt;/code&gt; and &lt;code&gt;FAILURE&lt;/code&gt; constants, and also
implements &lt;code&gt;From&amp;lt;u8&amp;gt;&lt;/code&gt; for more arbitrary values. The &lt;code&gt;Termination&lt;/code&gt; trait can also be implemented for
your own types, allowing you to customize any kind of reporting before converting to an &lt;code&gt;ExitCode&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For example, here&#x27;s a type-safe way to write exit codes for a &lt;a href&#x3D;&quot;https://git-scm.com/docs/git-bisect#_bisect_run&quot;&gt;&lt;code&gt;git bisect run&lt;/code&gt;&lt;/a&gt; script:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;use std::process::{ExitCode, Termination};

#[repr(u8)]
pub enum GitBisectResult {
    Good &#x3D; 0,
    Bad &#x3D; 1,
    Skip &#x3D; 125,
    Abort &#x3D; 255,
}

impl Termination for GitBisectResult {
    fn report(self) -&amp;gt; ExitCode {
        // Maybe print a message here
        ExitCode::from(self as u8)
    }
}

fn main() -&amp;gt; GitBisectResult {
    std::panic::catch_unwind(|| {
        todo!(&amp;quot;test the commit&amp;quot;)
    }).unwrap_or(GitBisectResult::Abort)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#more-capabilities-for-const-fn&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;more-capabilities-for-const-fn&quot;&gt;&lt;/a&gt;More capabilities for &lt;code&gt;const fn&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Several incremental features have been stabilized in this release to enable more functionality in
&lt;code&gt;const&lt;/code&gt; functions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Basic handling of &lt;code&gt;fn&lt;/code&gt; pointers&lt;/strong&gt;: You can now create, pass, and cast function pointers in a
&lt;code&gt;const fn&lt;/code&gt;. For example, this could be useful to build compile-time function tables for an
interpreter. However, it is still not permitted to call &lt;code&gt;fn&lt;/code&gt; pointers.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Trait bounds&lt;/strong&gt;: You can now write trait bounds on generic parameters to &lt;code&gt;const fn&lt;/code&gt;, such as
&lt;code&gt;T: Copy&lt;/code&gt;, where previously only &lt;code&gt;Sized&lt;/code&gt; was allowed.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;dyn Trait&lt;/code&gt; types&lt;/strong&gt;: Similarly, &lt;code&gt;const fn&lt;/code&gt; can now deal with trait objects, &lt;code&gt;dyn Trait&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;impl Trait&lt;/code&gt; types&lt;/strong&gt;: Arguments and return values for &lt;code&gt;const fn&lt;/code&gt; can now be opaque &lt;code&gt;impl Trait&lt;/code&gt;
types.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note that the trait features do not yet support calling methods from those traits in a &lt;code&gt;const fn&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;See the &lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/reference/const_eval.html&quot;&gt;Constant Evaluation&lt;/a&gt; section of
the reference book to learn more about the current capabilities of &lt;code&gt;const&lt;/code&gt; contexts, and future
capabilities can be tracked in &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/57563&quot;&gt;rust#57563&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#static-handles-for-locked-stdio&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;static-handles-for-locked-stdio&quot;&gt;&lt;/a&gt;Static handles for locked stdio&lt;/h3&gt;
&lt;p&gt;The three standard I/O streams -- &lt;code&gt;Stdin&lt;/code&gt;, &lt;code&gt;Stdout&lt;/code&gt;, and &lt;code&gt;Stderr&lt;/code&gt; -- each have a &lt;code&gt;lock(&amp;amp;self)&lt;/code&gt; to
allow more control over synchronizing read and writes. However, they returned lock guards with a
lifetime borrowed from &lt;code&gt;&amp;amp;self&lt;/code&gt;, so they were limited to the scope of the original handle. This was
determined to be an unnecessary limitation, since the underlying locks were actually in static
storage, so now the guards are returned with a &lt;code&gt;&#x27;static&lt;/code&gt; lifetime, disconnected from the handle.&lt;/p&gt;
&lt;p&gt;For example, a common error came from trying to get a handle and lock it in one statement:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;// error[E0716]: temporary value dropped while borrowed
let out &#x3D; std::io::stdout().lock();
//        ^^^^^^^^^^^^^^^^^       - temporary value is freed at the end of this statement
//        |
//        creates a temporary which is freed while still in use
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now the lock guard is &lt;code&gt;&#x27;static&lt;/code&gt;, not borrowing from that temporary, so this works!&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#stabilized-apis&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;stabilized-apis&quot;&gt;&lt;/a&gt;Stabilized APIs&lt;/h3&gt;
&lt;p&gt;The following methods and trait implementations are now stabilized:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/1.61.0/std/pin/struct.Pin.html#method.static_mut&quot;&gt;&lt;code&gt;Pin::static_mut&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/1.61.0/std/pin/struct.Pin.html#method.static_ref&quot;&gt;&lt;code&gt;Pin::static_ref&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/1.61.0/std/vec/struct.Vec.html#method.retain_mut&quot;&gt;&lt;code&gt;Vec::retain_mut&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/1.61.0/std/collections/struct.VecDeque.html#method.retain_mut&quot;&gt;&lt;code&gt;VecDeque::retain_mut&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/1.61.0/std/io/struct.Cursor.html#impl-Write-4&quot;&gt;&lt;code&gt;Write&lt;/code&gt; for &lt;code&gt;Cursor&amp;lt;[u8; N]&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/1.61.0/std/os/unix/net/struct.SocketAddr.html#method.from_pathname&quot;&gt;&lt;code&gt;std::os::unix::net::SocketAddr::from_pathname&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/1.61.0/std/process/struct.ExitCode.html&quot;&gt;&lt;code&gt;std::process::ExitCode&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/1.61.0/std/process/trait.Termination.html&quot;&gt;&lt;code&gt;std::process::Termination&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/1.61.0/std/thread/struct.JoinHandle.html#method.is_finished&quot;&gt;&lt;code&gt;std::thread::JoinHandle::is_finished&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following previously stable functions are now &lt;code&gt;const&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/1.61.0/std/primitive.pointer.html#method.offset&quot;&gt;&lt;code&gt;&amp;lt;*const T&amp;gt;::offset&lt;/code&gt;&lt;/a&gt;
and &lt;a href&#x3D;&quot;https://doc.rust-lang.org/1.61.0/std/primitive.pointer.html#method.offset-1&quot;&gt;&lt;code&gt;&amp;lt;*mut T&amp;gt;::offset&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/1.61.0/std/primitive.pointer.html#method.wrapping_offset&quot;&gt;&lt;code&gt;&amp;lt;*const T&amp;gt;::wrapping_offset&lt;/code&gt;&lt;/a&gt;
and &lt;a href&#x3D;&quot;https://doc.rust-lang.org/1.61.0/std/primitive.pointer.html#method.wrapping_offset-1&quot;&gt;&lt;code&gt;&amp;lt;*mut T&amp;gt;::wrapping_offset&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/1.61.0/std/primitive.pointer.html#method.add&quot;&gt;&lt;code&gt;&amp;lt;*const T&amp;gt;::add&lt;/code&gt;&lt;/a&gt;
and &lt;a href&#x3D;&quot;https://doc.rust-lang.org/1.61.0/std/primitive.pointer.html#method.add-1&quot;&gt;&lt;code&gt;&amp;lt;*mut T&amp;gt;::add&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/1.61.0/std/primitive.pointer.html#method.sub&quot;&gt;&lt;code&gt;&amp;lt;*const T&amp;gt;::sub&lt;/code&gt;&lt;/a&gt;
and &lt;a href&#x3D;&quot;https://doc.rust-lang.org/1.61.0/std/primitive.pointer.html#method.sub-1&quot;&gt;&lt;code&gt;&amp;lt;*mut T&amp;gt;::sub&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/1.61.0/std/primitive.pointer.html#method.wrapping_add&quot;&gt;&lt;code&gt;&amp;lt;*const T&amp;gt;::wrapping_add&lt;/code&gt;&lt;/a&gt;
and &lt;a href&#x3D;&quot;https://doc.rust-lang.org/1.61.0/std/primitive.pointer.html#method.wrapping_add-1&quot;&gt;&lt;code&gt;&amp;lt;*mut T&amp;gt;::wrapping_add&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/1.61.0/std/primitive.pointer.html#method.wrapping_sub&quot;&gt;&lt;code&gt;&amp;lt;*const T&amp;gt;::wrapping_sub&lt;/code&gt;&lt;/a&gt;
and &lt;a href&#x3D;&quot;https://doc.rust-lang.org/1.61.0/std/primitive.pointer.html#method.wrapping_sub-1&quot;&gt;&lt;code&gt;&amp;lt;*mut T&amp;gt;::wrapping_sub&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/1.61.0/std/primitive.slice.html#method.as_mut_ptr&quot;&gt;&lt;code&gt;&amp;lt;[T]&amp;gt;::as_mut_ptr&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/1.61.0/std/primitive.slice.html#method.as_ptr_range&quot;&gt;&lt;code&gt;&amp;lt;[T]&amp;gt;::as_ptr_range&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/1.61.0/std/primitive.slice.html#method.as_mut_ptr_range&quot;&gt;&lt;code&gt;&amp;lt;[T]&amp;gt;::as_mut_ptr_range&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#other-changes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;other-changes&quot;&gt;&lt;/a&gt;Other changes&lt;/h3&gt;
&lt;p&gt;There are other changes in the Rust 1.61.0 release. Check out what changed in
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1610-2022-05-19&quot;&gt;Rust&lt;/a&gt;,
&lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-161-2022-05-19&quot;&gt;Cargo&lt;/a&gt;,
and &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-161&quot;&gt;Clippy&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In a future release we&#x27;re planning to increase the baseline requirements for
the Linux kernel to version 3.2, and for glibc to version 2.17. We&#x27;d love
your feedback in &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/95026&quot;&gt;rust#95026&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#contributors-to-1610&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;contributors-to-1610&quot;&gt;&lt;/a&gt;Contributors to 1.61.0&lt;/h3&gt;
&lt;p&gt;Many people came together to create Rust 1.61.0.
We couldn&#x27;t have done it without all of you.
&lt;a href&#x3D;&quot;https://thanks.rust-lang.org/rust/1.61.0/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Security advisory: malicious crate rustdecimal</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/05/10/malicious-crate-rustdecimal.html" type="text/html" title="Security advisory: malicious crate rustdecimal" />
        <published>2022-05-10T00:00:00+00:00</published>
        <updated>2022-05-10T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/05/10/malicious-crate-rustdecimal.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/05/10/malicious-crate-rustdecimal.html">&lt;blockquote&gt;
&lt;p&gt;This is a cross-post of &lt;a href&#x3D;&quot;https://groups.google.com/g/rustlang-security-announcements/c/5DVtC8pgJLw&quot;&gt;the official security advisory&lt;/a&gt;. The
official advisory contains a signed version with our PGP key, as well.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The Rust Security Response WG and the crates.io team &lt;a href&#x3D;&quot;https://github.com/paupino/rust-decimal/issues/514#issuecomment-1115408888&quot;&gt;were notified&lt;/a&gt; on
2022-05-02 of the existence of the malicious crate &lt;code&gt;rustdecimal&lt;/code&gt;, which
contained malware. The crate name was intentionally similar to the name of the
popular &lt;a href&#x3D;&quot;https://crates.io/crates/rust_decimal&quot;&gt;&lt;code&gt;rust_decimal&lt;/code&gt;&lt;/a&gt; crate, hoping that potential victims would misspell
its name (an attack called &amp;quot;typosquatting&amp;quot;).&lt;/p&gt;
&lt;p&gt;To protect the security of the ecosystem, the crates.io team permanently
removed the crate from the registry as soon as it was made aware of the
malware. An analysis of all the crates on crates.io was also performed, and no
other crate with similar code patterns was found.&lt;/p&gt;
&lt;p&gt;Keep in mind that the &lt;a href&#x3D;&quot;https://crates.io/crates/rust_decimal&quot;&gt;&lt;code&gt;rust_decimal&lt;/code&gt;&lt;/a&gt; crate was &lt;strong&gt;not&lt;/strong&gt; compromised, and it
is still safe to use.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#analysis-of-the-crate&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;analysis-of-the-crate&quot;&gt;&lt;/a&gt;Analysis of the crate&lt;/h2&gt;
&lt;p&gt;The crate had less than 500 downloads since its first release on 2022-03-25,
and no crates on the crates.io registry depended on it.&lt;/p&gt;
&lt;p&gt;The crate contained identical source code and functionality as the legit
&lt;code&gt;rust_decimal&lt;/code&gt; crate, except for the &lt;code&gt;Decimal::new&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;When the function was called, it checked whether the &lt;code&gt;GITLAB_CI&lt;/code&gt; environment
variable was set, and if so it downloaded a binary payload into
&lt;code&gt;/tmp/git-updater.bin&lt;/code&gt; and executed it. The binary payload supported both Linux
and macOS, but not Windows.&lt;/p&gt;
&lt;p&gt;An analysis of the binary payload was not possible, as the download URL didn&#x27;t
work anymore when the analysis was performed.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#recommendations&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;recommendations&quot;&gt;&lt;/a&gt;Recommendations&lt;/h2&gt;
&lt;p&gt;If your project or organization is running GitLab CI, we strongly recommend
checking whether your project or one of its dependencies depended on the
&lt;code&gt;rustdecimal&lt;/code&gt; crate, starting from 2022-03-25. If you notice a dependency on
that crate, you should consider your CI environment to be compromised.&lt;/p&gt;
&lt;p&gt;In general, we recommend regularly auditing your dependencies, and only
depending on crates whose author you trust. If you notice any suspicious
behavior in a crate&#x27;s source code please follow &lt;a href&#x3D;&quot;https://www.rust-lang.org/policies/security&quot;&gt;the Rust security
policy&lt;/a&gt; and report it to the Rust Security Response WG.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#acknowledgements&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;acknowledgements&quot;&gt;&lt;/a&gt;Acknowledgements&lt;/h2&gt;
&lt;p&gt;We want to thank GitHub user &lt;a href&#x3D;&quot;https://github.com/safinaskar&quot;&gt;&lt;code&gt;@safinaskar&lt;/code&gt;&lt;/a&gt; for identifying the
malicious crate in &lt;a href&#x3D;&quot;https://github.com/paupino/rust-decimal/issues/514#issuecomment-1115408888&quot;&gt;this GitHub issue&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Security Response WG</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.60.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/04/07/Rust-1.60.0.html" type="text/html" title="Announcing Rust 1.60.0" />
        <published>2022-04-07T00:00:00+00:00</published>
        <updated>2022-04-07T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/04/07/Rust-1.60.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/04/07/Rust-1.60.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.60.0. Rust is a programming language empowering everyone to build reliable and efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, you can get 1.60.0 with:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-console&quot;&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt;
from the appropriate page on our website, and check out the
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1600-2022-04-07&quot;&gt;detailed release notes for 1.60.0&lt;/a&gt; on GitHub.
If you&#x27;d like to help us out by testing future releases, you might consider updating locally to use
the beta channel (&lt;code&gt;rustup default beta&lt;/code&gt;) or the nightly channel (&lt;code&gt;rustup default nightly&lt;/code&gt;). Please &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/new/choose&quot;&gt;report&lt;/a&gt; any bugs you might come across!&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-in-1600-stable&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-in-1600-stable&quot;&gt;&lt;/a&gt;What&#x27;s in 1.60.0 stable&lt;/h2&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#source-based-code-coverage&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;source-based-code-coverage&quot;&gt;&lt;/a&gt;Source-based Code Coverage&lt;/h3&gt;
&lt;p&gt;Support for LLVM-based coverage instrumentation has been stabilized in rustc. You can try this out on your code by rebuilding your code with &lt;code&gt;-Cinstrument-coverage&lt;/code&gt;, for example like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-shell&#x3D;&quot;&gt;RUSTFLAGS&#x3D;&amp;quot;-C instrument-coverage&amp;quot; cargo build
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After that, you can run the resulting binary, which will produce a
&lt;code&gt;default.profraw&lt;/code&gt; file in the current directory. (The path and filename can be
overriden by an environment variable; see
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/rustc/instrument-coverage.html#running-the-instrumented-binary-to-generate-raw-coverage-profiling-data&quot;&gt;documentation&lt;/a&gt;
for details).&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;llvm-tools-preview&lt;/code&gt; component includes &lt;code&gt;llvm-profdata&lt;/code&gt; for processing and
merging raw profile output (coverage region execution counts); and &lt;code&gt;llvm-cov&lt;/code&gt;
for report generation. &lt;code&gt;llvm-cov&lt;/code&gt; combines the processed output, from
&lt;code&gt;llvm-profdata&lt;/code&gt;, and the binary itself, because the binary embeds a mapping from
counters to actual source code regions.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-shell&#x3D;&quot;&gt;rustup component add llvm-tools-preview
$(rustc --print sysroot)/lib/rustlib/x86_64-unknown-linux-gnu/bin/llvm-profdata merge -sparse default.profraw -o default.profdata
$(rustc --print sysroot)/lib/rustlib/x86_64-unknown-linux-gnu/bin/llvm-cov show -Xdemangler&#x3D;rustfilt target/debug/coverage-testing \
    -instr-profile&#x3D;default.profdata \
    -show-line-counts-or-regions \
    -show-instantiations
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above commands on a simple helloworld binary produce this annotated report, showing that each line of the input was covered.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    1|      1|fn main() {
    2|      1|    println!(&amp;quot;Hello, world!&amp;quot;);
    3|      1|}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For more details, please read the
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/rustc/instrument-coverage.html&quot;&gt;documentation&lt;/a&gt; in the
rustc book. The baseline functionality is stable and will exist in some form
in all future Rust releases, but the specific output format and LLVM tooling which
produces it are subject to change. For this reason, it is important to make
sure that you use the same version for both the &lt;code&gt;llvm-tools-preview&lt;/code&gt; and the
rustc binary used to compile your code.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#cargo---timings&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;cargo---timings&quot;&gt;&lt;/a&gt;&lt;code&gt;cargo --timings&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Cargo has stabilized support for collecting information on build with the &lt;code&gt;--timings&lt;/code&gt; flag.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-shell&quot;&gt;$ cargo build --timings
   Compiling hello-world v0.1.0 (hello-world)
      Timing report saved to target/cargo-timings/cargo-timing-20220318T174818Z.html
    Finished dev [unoptimized + debuginfo] target(s) in 0.98s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The report is also copied to &lt;code&gt;target/cargo-timings/cargo-timing.html&lt;/code&gt;. A report on the release build of Cargo has been put up &lt;a href&#x3D;&quot;../../../images/2022-04-07-timing.html&quot;&gt;here&lt;/a&gt;. These reports can be useful for improving build performance.
More information about the timing reports may be found in the &lt;a href&#x3D;&quot;https://doc.rust-lang.org/nightly/cargo/reference/timings.html&quot;&gt;documentation&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#new-syntax-for-cargo-features&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;new-syntax-for-cargo-features&quot;&gt;&lt;/a&gt;New syntax for Cargo features&lt;/h3&gt;
&lt;p&gt;This release introduces two new changes to improve support for &lt;a href&#x3D;&quot;https://doc.rust-lang.org/cargo/reference/features.html&quot;&gt;Cargo features&lt;/a&gt; and how they interact with &lt;a href&#x3D;&quot;https://doc.rust-lang.org/cargo/reference/features.html#optional-dependencies&quot;&gt;optional dependencies&lt;/a&gt;: Namespaced dependencies and weak dependency features.&lt;/p&gt;
&lt;p&gt;Cargo has long supported features along with optional dependencies, as illustrated by the snippet below.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-toml&quot;&gt;[dependencies]
jpeg-decoder &#x3D; { version &#x3D; &amp;quot;0.1.20&amp;quot;, default-features &#x3D; false, optional &#x3D; true }

[features]
# Enables parallel processing support by enabling the &amp;quot;rayon&amp;quot; feature of jpeg-decoder.
parallel &#x3D; [&amp;quot;jpeg-decoder/rayon&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are two things to note in this example:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The optional dependency &lt;code&gt;jpeg-decoder&lt;/code&gt; implicitly defines a feature of the same name. Enabling the &lt;code&gt;jpeg-decoder&lt;/code&gt; feature will enable the &lt;code&gt;jpeg-decoder&lt;/code&gt; dependency.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;&amp;quot;jpeg-decoder/rayon&amp;quot;&lt;/code&gt; syntax enables the &lt;code&gt;jpeg-decoder&lt;/code&gt; dependency &lt;em&gt;and&lt;/em&gt; enables the &lt;code&gt;jpeg-decoder&lt;/code&gt; dependency&#x27;s &lt;code&gt;rayon&lt;/code&gt; feature.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Namespaced features tackles the first issue. You can now use the &lt;code&gt;dep:&lt;/code&gt; prefix in the &lt;code&gt;[features]&lt;/code&gt; table to explicitly refer to an optional dependency without implicitly exposing it as a feature. This gives you more control on how to define the feature corresponding to the optional dependency including hiding optional dependencies behind more descriptive feature names.&lt;/p&gt;
&lt;p&gt;Weak dependency features tackle the second issue where the &lt;code&gt;&amp;quot;optional-dependency/feature-name&amp;quot;&lt;/code&gt; syntax would always enable &lt;code&gt;optional-dependency&lt;/code&gt;. However, often you want to enable the feature on the optional dependency &lt;em&gt;only&lt;/em&gt; if some other feature has enabled the optional dependency. Starting in 1.60, you can add a ? as in &lt;code&gt;&amp;quot;package-name?/feature-name&amp;quot;&lt;/code&gt; which will only enable the given feature if something else has enabled the optional dependency.&lt;/p&gt;
&lt;p&gt;For example, let&#x27;s say we have added some serialization support to our library, and it requires enabling a corresponding feature in some optional dependencies. That can be done like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-toml&quot;&gt;[dependencies]
serde &#x3D; { version &#x3D; &amp;quot;1.0.133&amp;quot;, optional &#x3D; true }
rgb &#x3D; { version &#x3D; &amp;quot;0.8.25&amp;quot;, optional &#x3D; true }

[features]
serde &#x3D; [&amp;quot;dep:serde&amp;quot;, &amp;quot;rgb?/serde&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, enabling the serde feature will enable the serde dependency. It will also enable the serde feature for the rgb dependency, but only if something else has enabled the rgb dependency.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#incremental-compilation-status&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;incremental-compilation-status&quot;&gt;&lt;/a&gt;Incremental compilation status&lt;/h3&gt;
&lt;p&gt;Incremental compilation is re-enabled for the 1.60 release. The Rust team continues to work on fixing bugs in incremental, but no problems causing widespread breakage are known at this time, so we have chosen to reenable incremental compilation. Additionally, the compiler team is continuing to work on long-term strategy to avoid future problems of this kind. That process is in relatively early days, so we don&#x27;t have anything to share yet on that front.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#instant-monotonicity-guarantees&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;instant-monotonicity-guarantees&quot;&gt;&lt;/a&gt;&lt;code&gt;Instant&lt;/code&gt; monotonicity guarantees&lt;/h3&gt;
&lt;p&gt;On all platforms &lt;code&gt;Instant&lt;/code&gt; will try to use an OS API that guarantees monotonic
behavior if available (which is the case on all tier 1 platforms). In practice
such guarantees are -- under rare circumstances -- broken by hardware,
virtualization, or operating system bugs. To work around these bugs and platforms
not offering monotonic clocks, &lt;code&gt;Instant::duration_since&lt;/code&gt;, &lt;code&gt;Instant::elapsed&lt;/code&gt; and
&lt;code&gt;Instant::sub&lt;/code&gt; now saturate to zero. In older Rust versions this led to a panic
instead. &lt;code&gt;Instant::checked_duration_since&lt;/code&gt; can be used to detect and handle
situations where monotonicity is violated, or &lt;code&gt;Instant&lt;/code&gt;s are subtracted in the
wrong order.&lt;/p&gt;
&lt;p&gt;This workaround obscures programming errors where earlier and later instants are
accidentally swapped. For this reason future Rust versions may reintroduce
panics in at least those cases, if possible and efficient.&lt;/p&gt;
&lt;p&gt;Prior to 1.60, the monotonicity guarantees were provided through mutexes or
atomics in std, which can introduce large performance overheads to
&lt;code&gt;Instant::now()&lt;/code&gt;. Additionally, the panicking behavior meant that Rust software
could panic in a subset of environments, which was largely undesirable, as the
authors of that software may not be able to fix or upgrade the operating system,
hardware, or virtualization system they are running on. Further, introducing
unexpected panics into these environments made Rust software less reliable and
portable, which is of higher concern than exposing typically uninteresting
platform bugs in monotonic clock handling to end users.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#stabilized-apis&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;stabilized-apis&quot;&gt;&lt;/a&gt;Stabilized APIs&lt;/h3&gt;
&lt;p&gt;The following methods and trait implementations are now stabilized:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/sync/struct.Arc.html#method.new_cyclic&quot;&gt;&lt;code&gt;Arc::new_cyclic&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/rc/struct.Rc.html#method.new_cyclic&quot;&gt;&lt;code&gt;Rc::new_cyclic&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/slice/struct.EscapeAscii.html&quot;&gt;&lt;code&gt;slice::EscapeAscii&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.slice.html#method.escape_ascii&quot;&gt;&lt;code&gt;&amp;lt;[u8]&amp;gt;::escape_ascii&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.u8.html#method.escape_ascii&quot;&gt;&lt;code&gt;u8::escape_ascii&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/vec/struct.Vec.html#method.spare_capacity_mut&quot;&gt;&lt;code&gt;Vec::spare_capacity_mut&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/mem/union.MaybeUninit.html#method.assume_init_drop&quot;&gt;&lt;code&gt;MaybeUninit::assume_init_drop&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/mem/union.MaybeUninit.html#method.assume_init_read&quot;&gt;&lt;code&gt;MaybeUninit::assume_init_read&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.i8.html#method.abs_diff&quot;&gt;&lt;code&gt;i8::abs_diff&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.i16.html#method.abs_diff&quot;&gt;&lt;code&gt;i16::abs_diff&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.i32.html#method.abs_diff&quot;&gt;&lt;code&gt;i32::abs_diff&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.i64.html#method.abs_diff&quot;&gt;&lt;code&gt;i64::abs_diff&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.i128.html#method.abs_diff&quot;&gt;&lt;code&gt;i128::abs_diff&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.isize.html#method.abs_diff&quot;&gt;&lt;code&gt;isize::abs_diff&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.u8.html#method.abs_diff&quot;&gt;&lt;code&gt;u8::abs_diff&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.u16.html#method.abs_diff&quot;&gt;&lt;code&gt;u16::abs_diff&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.u32.html#method.abs_diff&quot;&gt;&lt;code&gt;u32::abs_diff&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.u64.html#method.abs_diff&quot;&gt;&lt;code&gt;u64::abs_diff&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.u128.html#method.abs_diff&quot;&gt;&lt;code&gt;u128::abs_diff&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.usize.html#method.abs_diff&quot;&gt;&lt;code&gt;usize::abs_diff&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/io/enum.ErrorKind.html#impl-Display&quot;&gt;&lt;code&gt;Display for io::ErrorKind&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/process/struct.ExitCode.html#impl-From%3Cu8%3E&quot;&gt;&lt;code&gt;From&amp;lt;u8&amp;gt; for ExitCode&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.never.html#impl-Not&quot;&gt;&lt;code&gt;Not for !&lt;/code&gt; (the &amp;quot;never&amp;quot; type)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.Wrapping.html#trait-implementations&quot;&gt;_Op_&lt;code&gt;Assign&amp;lt;$t&amp;gt; for Wrapping&amp;lt;$t&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/arch/macro.is_aarch64_feature_detected.html&quot;&gt;&lt;code&gt;arch::is_aarch64_feature_detected!&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#other-changes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;other-changes&quot;&gt;&lt;/a&gt;Other changes&lt;/h3&gt;
&lt;p&gt;There are other changes in the Rust 1.60.0 release. Check out what changed in
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1600-2022-04-07&quot;&gt;Rust&lt;/a&gt;,
&lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-160-2022-04-07&quot;&gt;Cargo&lt;/a&gt;,
and &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-160&quot;&gt;Clippy&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#contributors-to-1600&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;contributors-to-1600&quot;&gt;&lt;/a&gt;Contributors to 1.60.0&lt;/h3&gt;
&lt;p&gt;Many people came together to create Rust 1.60.0.
We couldn&#x27;t have done it without all of you.
&lt;a href&#x3D;&quot;https://thanks.rust-lang.org/rust/1.60.0/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Security advisory for the regex crate (CVE-2022-24713)</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/03/08/cve-2022-24713.html" type="text/html" title="Security advisory for the regex crate (CVE-2022-24713)" />
        <published>2022-03-08T00:00:00+00:00</published>
        <updated>2022-03-08T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/03/08/cve-2022-24713.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/03/08/cve-2022-24713.html">&lt;blockquote&gt;
&lt;p&gt;This is a cross-post of &lt;a href&#x3D;&quot;https://groups.google.com/g/rustlang-security-announcements/c/NcNNL1Jq7Yw&quot;&gt;the official security advisory&lt;/a&gt;. The
official advisory contains a signed version with our PGP key, as well.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The Rust Security Response WG was notified that the &lt;code&gt;regex&lt;/code&gt; crate did not
properly limit the complexity of the regular expressions (regex) it parses. An
attacker could use this security issue to perform a denial of service, by
sending a specially crafted regex to a service accepting untrusted regexes. No
known vulnerability is present when parsing untrusted input with trusted
regexes.&lt;/p&gt;
&lt;p&gt;This issue has been assigned CVE-2022-24713. The severity of this vulnerability
is &amp;quot;high&amp;quot; when the &lt;code&gt;regex&lt;/code&gt; crate is used to parse untrusted regexes. Other uses
of the &lt;code&gt;regex&lt;/code&gt; crate are not affected by this vulnerability.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#overview&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;regex&lt;/code&gt; crate features built-in mitigations to prevent denial of service
attacks caused by untrusted regexes, or untrusted input matched by trusted
regexes. Those (tunable) mitigations already provide sane defaults to prevent
attacks. This guarantee is documented and it&#x27;s considered part of the crate&#x27;s
API.&lt;/p&gt;
&lt;p&gt;Unfortunately a bug was discovered in the mitigations designed to prevent
untrusted regexes to take an arbitrary amount of time during parsing, and it&#x27;s
possible to craft regexes that bypass such mitigations. This makes it possible
to perform denial of service attacks by sending specially crafted regexes to
services accepting user-controlled, untrusted regexes.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#affected-versions&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;affected-versions&quot;&gt;&lt;/a&gt;Affected versions&lt;/h2&gt;
&lt;p&gt;All versions of the &lt;code&gt;regex&lt;/code&gt; crate before or equal to 1.5.4 are affected by this
issue. The fix is included starting from  &lt;code&gt;regex&lt;/code&gt; 1.5.5.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#mitigations&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;mitigations&quot;&gt;&lt;/a&gt;Mitigations&lt;/h2&gt;
&lt;p&gt;We recommend everyone accepting user-controlled regexes to upgrade immediately
to the latest version of the &lt;code&gt;regex&lt;/code&gt; crate.&lt;/p&gt;
&lt;p&gt;Unfortunately there is no fixed set of problematic regexes, as there are
practically infinite regexes that could be crafted to exploit this
vulnerability. Because of this, we do not recommend denying known problematic
regexes.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#acknowledgements&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;acknowledgements&quot;&gt;&lt;/a&gt;Acknowledgements&lt;/h2&gt;
&lt;p&gt;We want to thank Addison Crump for responsibly disclosing this to us according
to the &lt;a href&#x3D;&quot;https://www.rust-lang.org/policies/security&quot;&gt;Rust security policy&lt;/a&gt;, and for helping review the fix.&lt;/p&gt;
&lt;p&gt;We also want to thank Andrew Gallant for developing the fix, and Pietro Albini
for coordinating the disclosure and writing this advisory.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Security Response WG</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.59.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/02/24/Rust-1.59.0.html" type="text/html" title="Announcing Rust 1.59.0" />
        <published>2022-02-24T00:00:00+00:00</published>
        <updated>2022-02-24T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/02/24/Rust-1.59.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/02/24/Rust-1.59.0.html">&lt;p&gt;The Rust team has published a new version of Rust, 1.59.0. Rust is a programming
language that is empowering everyone to build reliable and efficient software.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Today&#x27;s release falls on the day in which the world&#x27;s attention is captured by
the sudden invasion of Ukraine by Putin&#x27;s forces. Before going into the details
of the new Rust release, we&#x27;d like to state that we stand in solidarity with the
people of Ukraine and express our support for all people affected by this
conflict.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, you can get 1.59.0
with:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-console&quot;&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt;
from the appropriate page on our website, and check out the
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1590-2022-02-24&quot;&gt;detailed release notes for 1.59.0&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-in-1590-stable&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-in-1590-stable&quot;&gt;&lt;/a&gt;What&#x27;s in 1.59.0 stable&lt;/h2&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#inline-assembly&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;inline-assembly&quot;&gt;&lt;/a&gt;Inline assembly&lt;/h3&gt;
&lt;p&gt;The Rust language now supports inline assembly. This enables many applications
that need very low-level control over their execution, or access to
specialized machine instructions.&lt;/p&gt;
&lt;p&gt;When compiling for x86-64 targets, for instance, you can now write:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;use std::arch::asm;

// Multiply x by 6 using shifts and adds
let mut x: u64 &#x3D; 4;
unsafe {
    asm!(
        &amp;quot;mov {tmp}, {x}&amp;quot;,
        &amp;quot;shl {tmp}, 1&amp;quot;,
        &amp;quot;shl {x}, 2&amp;quot;,
        &amp;quot;add {x}, {tmp}&amp;quot;,
        x &#x3D; inout(reg) x,
        tmp &#x3D; out(reg) _,
    );
}
assert_eq!(x, 4 * 6);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The format string syntax used to name registers in the &lt;code&gt;asm!&lt;/code&gt; and &lt;code&gt;global_asm!&lt;/code&gt;
macros is the same used in Rust &lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/fmt/&quot;&gt;format strings&lt;/a&gt;, so it should feel quite familiar
to Rust programmers.&lt;/p&gt;
&lt;p&gt;The assembly language and instructions available with inline assembly vary
according to the target architecture. Today, the stable Rust compiler supports
inline assembly on the following architectures:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;x86 and x86-64&lt;/li&gt;
&lt;li&gt;ARM&lt;/li&gt;
&lt;li&gt;AArch64&lt;/li&gt;
&lt;li&gt;RISC-V&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can see more examples of inline assembly in &lt;a href&#x3D;&quot;https://doc.rust-lang.org/nightly/rust-by-example/unsafe/asm.html&quot;&gt;Rust By Example&lt;/a&gt;,
and find more detailed documentation in the &lt;a href&#x3D;&quot;https://doc.rust-lang.org/nightly/reference/inline-assembly.html&quot;&gt;reference&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#destructuring-assignments&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;destructuring-assignments&quot;&gt;&lt;/a&gt;Destructuring assignments&lt;/h3&gt;
&lt;p&gt;You can now use tuple, slice, and struct patterns as the left-hand side of an
assignment.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;let (a, b, c, d, e);

(a, b) &#x3D; (1, 2);
[c, .., d, _] &#x3D; [1, 2, 3, 4, 5];
Struct { e, .. } &#x3D; Struct { e: 5, f: 3 };

assert_eq!([1, 2, 1, 4, 5], [a, b, c, d, e]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This makes assignment more consistent with &lt;code&gt;let&lt;/code&gt; bindings, which have long
supported the same thing. Note that destructuring assignments with operators
such as &lt;code&gt;+&#x3D;&lt;/code&gt; are not allowed.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#const-generics-defaults-and-interleaving&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;const-generics-defaults-and-interleaving&quot;&gt;&lt;/a&gt;Const generics defaults and interleaving&lt;/h3&gt;
&lt;p&gt;Generic types can now specify default values for their const generics. For
example, you can now write the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;struct ArrayStorage&amp;lt;T, const N: usize &#x3D; 2&amp;gt; {
    arr: [T; N],
}

impl&amp;lt;T&amp;gt; ArrayStorage&amp;lt;T&amp;gt; {
    fn new(a: T, b: T) -&amp;gt; ArrayStorage&amp;lt;T&amp;gt; {
        ArrayStorage {
            arr: [a, b],
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Previously, type parameters were required to come before all const parameters.
That restriction has been relaxed and you can now interleave them.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;fn cartesian_product&amp;lt;
    T, const N: usize,
    U, const M: usize,
    V, F
&amp;gt;(a: [T; N], b: [U; M], f: F) -&amp;gt; [[V; N]; M]
where
    F: FnMut(&amp;amp;T, &amp;amp;U) -&amp;gt; V
{
    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#future-incompatibility-warnings&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;future-incompatibility-warnings&quot;&gt;&lt;/a&gt;Future incompatibility warnings&lt;/h3&gt;
&lt;p&gt;Sometimes bugs in the Rust compiler cause it to accept code that should not
have been accepted. An example of this was &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/46043&quot;&gt;borrows of packed struct
fields&lt;/a&gt; being allowed in safe code.&lt;/p&gt;
&lt;p&gt;While this happens very rarely, it can be quite disruptive when a crate used by
your project has code that will no longer be allowed. In fact, you might not
notice until your project inexplicably stops building!&lt;/p&gt;
&lt;p&gt;Cargo now shows you warnings when a dependency will be rejected by a future
version of Rust. After running &lt;code&gt;cargo build&lt;/code&gt; or &lt;code&gt;cargo check&lt;/code&gt;, you might see:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;warning: the following packages contain code that will be rejected by a future version of Rust: old_dep v0.1.0
note: to see what the problems were, use the option &#x60;--future-incompat-report&#x60;, or run &#x60;cargo report future-incompatibilities --id 1&#x60;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can run the &lt;code&gt;cargo report&lt;/code&gt; command mentioned in the warning to see a full
report of the code that will be rejected. This gives you time to upgrade your
dependency before it breaks your build.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#creating-stripped-binaries&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;creating-stripped-binaries&quot;&gt;&lt;/a&gt;Creating stripped binaries&lt;/h3&gt;
&lt;p&gt;It&#x27;s often useful to strip unnecessary information like debuginfo from binaries
you distribute, making them smaller.&lt;/p&gt;
&lt;p&gt;While it has always been possible to do this manually after the binary is
created, cargo and rustc now support stripping when the binary is linked. To
enable this, add the following to your &lt;code&gt;Cargo.toml&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-toml&quot;&gt;[profile.release]
strip &#x3D; &amp;quot;debuginfo&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This causes debuginfo to be stripped from release binaries. You can also supply
&lt;code&gt;&amp;quot;symbols&amp;quot;&lt;/code&gt; or just &lt;code&gt;true&lt;/code&gt; to strip all symbol information where supported.&lt;/p&gt;
&lt;p&gt;The standard library typically ships with debug symbols and line-level
debuginfo, so Rust binaries built without debug symbols enabled still include
the debug information from the standard library by default. Using the &lt;code&gt;strip&lt;/code&gt;
option allows you to remove this extra information, producing smaller Rust
binaries.&lt;/p&gt;
&lt;p&gt;See &lt;a href&#x3D;&quot;https://doc.rust-lang.org/beta/cargo/reference/profiles.html#strip&quot;&gt;Cargo&#x27;s documentation&lt;/a&gt; for more details.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#incremental-compilation-off-by-default&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;incremental-compilation-off-by-default&quot;&gt;&lt;/a&gt;Incremental compilation off by default&lt;/h3&gt;
&lt;p&gt;The 1.59.0 release disables incremental by default (unless explicitly asked for
by via an environment variable: &lt;code&gt;RUSTC_FORCE_INCREMENTAL&#x3D;1&lt;/code&gt;). This mitigates
the effects of a known bug, &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/94124&quot;&gt;#94124&lt;/a&gt;, which can cause deserialization errors (and panics) during compilation
with incremental compilation turned on.&lt;/p&gt;
&lt;p&gt;The specific fix for &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/94124&quot;&gt;#94124&lt;/a&gt; has landed and is currently in the 1.60 beta,
which will ship in six weeks. We are not presently aware of other issues that
would encourage a decision to disable incremental in 1.60 stable, and if none
arise it is likely that 1.60 stable will re-enable incremental compilation
again. Incremental compilation remains on by default in the beta and nightly
channels.&lt;/p&gt;
&lt;p&gt;As always, we encourage users to test on the nightly and beta channels and
report issues you find: particularly for incremental bugs, this is the best way
to ensure the Rust team can judge whether there is breakage and the number of
users it affects.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#stabilized-apis&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;stabilized-apis&quot;&gt;&lt;/a&gt;Stabilized APIs&lt;/h3&gt;
&lt;p&gt;The following methods and trait implementations are now stabilized:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/thread/fn.available_parallelism.html&quot;&gt;&lt;code&gt;std::thread::available_parallelism&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/result/enum.Result.html#method.copied&quot;&gt;&lt;code&gt;Result::copied&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/result/enum.Result.html#method.cloned&quot;&gt;&lt;code&gt;Result::cloned&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/core/arch/macro.asm.html&quot;&gt;&lt;code&gt;arch::asm!&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/core/arch/macro.global_asm.html&quot;&gt;&lt;code&gt;arch::global_asm!&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ops/enum.ControlFlow.html#method.is_break&quot;&gt;&lt;code&gt;ops::ControlFlow::is_break&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ops/enum.ControlFlow.html#method.is_continue&quot;&gt;&lt;code&gt;ops::ControlFlow::is_continue&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.char.html#impl-TryFrom%3Cchar%3E&quot;&gt;&lt;code&gt;TryFrom&amp;lt;char&amp;gt; for u8&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/char/struct.TryFromCharError.html&quot;&gt;&lt;code&gt;char::TryFromCharError&lt;/code&gt;&lt;/a&gt;
implementing &lt;code&gt;Clone&lt;/code&gt;, &lt;code&gt;Debug&lt;/code&gt;, &lt;code&gt;Display&lt;/code&gt;, &lt;code&gt;PartialEq&lt;/code&gt;, &lt;code&gt;Copy&lt;/code&gt;, &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Error&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/iter/fn.zip.html&quot;&gt;&lt;code&gt;iter::zip&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/core/num/struct.NonZeroU8.html#method.is_power_of_two&quot;&gt;&lt;code&gt;NonZeroU8::is_power_of_two&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/core/num/struct.NonZeroU16.html#method.is_power_of_two&quot;&gt;&lt;code&gt;NonZeroU16::is_power_of_two&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/core/num/struct.NonZeroU32.html#method.is_power_of_two&quot;&gt;&lt;code&gt;NonZeroU32::is_power_of_two&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/core/num/struct.NonZeroU64.html#method.is_power_of_two&quot;&gt;&lt;code&gt;NonZeroU64::is_power_of_two&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/core/num/struct.NonZeroU128.html#method.is_power_of_two&quot;&gt;&lt;code&gt;NonZeroU128::is_power_of_two&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/char/struct.ToLowercase.html#impl-DoubleEndedIterator&quot;&gt;&lt;code&gt;DoubleEndedIterator for ToLowercase&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/char/struct.ToUppercase.html#impl-DoubleEndedIterator&quot;&gt;&lt;code&gt;DoubleEndedIterator for ToUppercase&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/convert/trait.TryFrom.html#impl-TryFrom%3C%26%27_%20mut%20%5BT%5D%3E&quot;&gt;&lt;code&gt;TryFrom&amp;lt;&amp;amp;mut [T]&amp;gt; for [T; N]&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/sync/struct.Once.html#impl-UnwindSafe&quot;&gt;&lt;code&gt;UnwindSafe for Once&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/sync/struct.Once.html#impl-RefUnwindSafe&quot;&gt;&lt;code&gt;RefUnwindSafe for Once&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/stdarch/pull/1266&quot;&gt;armv8 neon intrinsics for aarch64&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following previously stable functions are now &lt;code&gt;const&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/mem/union.MaybeUninit.html#method.as_ptr&quot;&gt;&lt;code&gt;mem::MaybeUninit::as_ptr&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/mem/union.MaybeUninit.html#method.assume_init&quot;&gt;&lt;code&gt;mem::MaybeUninit::assume_init&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/mem/union.MaybeUninit.html#method.assume_init_ref&quot;&gt;&lt;code&gt;mem::MaybeUninit::assume_init_ref&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/struct.CStr.html#method.from_bytes_with_nul_unchecked&quot;&gt;&lt;code&gt;ffi::CStr::from_bytes_with_nul_unchecked&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#other-changes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;other-changes&quot;&gt;&lt;/a&gt;Other changes&lt;/h3&gt;
&lt;p&gt;There are other changes in the Rust 1.59.0 release. Check out what changed in
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1590-2022-02-24&quot;&gt;Rust&lt;/a&gt;,
&lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-159-2022-02-24&quot;&gt;Cargo&lt;/a&gt;,
and &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-159&quot;&gt;Clippy&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#contributors-to-1590&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;contributors-to-1590&quot;&gt;&lt;/a&gt;Contributors to 1.59.0&lt;/h3&gt;
&lt;p&gt;Many people came together to create Rust 1.59.0.
We couldn&#x27;t have done it without all of you.
&lt;a href&#x3D;&quot;https://thanks.rust-lang.org/rust/1.59.0/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Team</name>
        </author>
    </entry>
    
    <entry>
        <title>rust-analyzer joins the Rust organization!</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/02/21/rust-analyzer-joins-rust-org.html" type="text/html" title="rust-analyzer joins the Rust organization!" />
        <published>2022-02-21T00:00:00+00:00</published>
        <updated>2022-02-21T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/02/21/rust-analyzer-joins-rust-org.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/02/21/rust-analyzer-joins-rust-org.html">&lt;p&gt;We have an exciting announcement to make!
The &lt;a href&#x3D;&quot;https://rust-analyzer.github.io&quot;&gt;rust-analyzer&lt;/a&gt; project, a new implementation of the Language Server Protocol (LSP) for Rust, is now officially a part of the wider Rust organization! ðŸŽ‰&lt;/p&gt;
&lt;p&gt;We want to start by thanking everyone who has gotten us this far, from contributors, to sponsors, to all the users of rust-analyzer in the Rust community. We could not have done this without you.&lt;/p&gt;
&lt;p&gt;The immediate impact of this organizational change is limited -- nothing changes for rust-analyzer users or contributors.
However, this change unblocks technical work to make rust-analyzer the officially recommended language server for Rust in the near future.&lt;/p&gt;
&lt;p&gt;If you were hesitant to try rust-analyzer before, today is a good opportunity to do so.
Not only is it a very capable language server for Rust, but according to &lt;a href&#x3D;&quot;https://marketplace.visualstudio.com/search?target&#x3D;VSCode&amp;category&#x3D;Programming%20Languages&amp;sortBy&#x3D;Rating&quot;&gt;VS Code statistics&lt;/a&gt;, it is one of the best rated LSP implementations &lt;em&gt;across&lt;/em&gt; programming languages.
We highly recommend giving rust-analyzer a spin today, even if it will take some more time for us to complete the due process and switch from the existing officially recommended LSP implementation (RLS) properly.&lt;/p&gt;
&lt;p&gt;rust-analyzer enjoys excellent support in many editors:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For VS Code, install the &lt;a href&#x3D;&quot;https://marketplace.visualstudio.com/items?itemName&#x3D;matklad.rust-analyzer&quot;&gt;rust-analyzer&lt;/a&gt; extension from the marketplace.&lt;/li&gt;
&lt;li&gt;For Neovim, follow the setup instructions &lt;a href&#x3D;&quot;https://sharksforarms.dev/posts/neovim-rust/&quot;&gt;from this post&lt;/a&gt;.
For Vim, see &lt;a href&#x3D;&quot;https://github.com/fannheyward/coc-rust-analyzer&quot;&gt;coc-rust-analyzer&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;For Emacs, follow the setup instructions &lt;a href&#x3D;&quot;https://robert.kra.hn/posts/2021-02-07_rust-with-emacs/&quot;&gt;from this post&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For other editors, check &lt;a href&#x3D;&quot;https://rust-analyzer.github.io/manual.html&quot;&gt;the manual&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Finally, if you are using IntelliJ-Platform based IDEs like CLion, IDEA or PyCharm, you don&#x27;t need rust-analyzer.
You should use the awesome &lt;a href&#x3D;&quot;https://intellij-rust.github.io&quot;&gt;IntelliJ Rust&lt;/a&gt; plugin by JetBrains.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#history-and-future&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;history-and-future&quot;&gt;&lt;/a&gt;History and Future&lt;/h2&gt;
&lt;p&gt;The rust-analyzer project was started at the very end of 2017 (&lt;a href&#x3D;&quot;https://github.com/rust-analyzer/rust-analyzer/commit/a63222cd240d9b5405826783603f3b391c90885d&quot;&gt;first commit&lt;/a&gt;).
At that time, the existing LSP implementation, RLS, had been providing IDE support for Rust for several years.
While it handled well the most important features, it was clearly far from the experience offered by state-of-the-art IDEs for some other languages.&lt;/p&gt;
&lt;p&gt;Originally, the plan was to just experiment with error-resilient parsing for Rust; but when you have a good parser, it is so tempting &lt;a href&#x3D;&quot;https://github.com/rust-analyzer/rust-analyzer/commit/d7c5a6f3081c2e7266620779d3c32067f947b959&quot;&gt;to add a simple LSP server&lt;/a&gt; on top of it.
Long story short, it took surprisingly little effort to get to a prototype which was already useful as an IDE, which happened in Autumn 2018.
At that critical point, the company &lt;a href&#x3D;&quot;https://ferrous-systems.com&quot;&gt;Ferrous Systems&lt;/a&gt; (which was newborn itself) stepped in to fund further development of the prototype.&lt;/p&gt;
&lt;p&gt;During 2019, the then nascent rust-analyzer community worked hard to build out the foundation of an IDE.
By 2020, we realized that what we had built was no longer a prototype, but an already tremendously useful tool for day-to-day Rust programming.
This culminated in &lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/pull/2912&quot;&gt;RFC2912&lt;/a&gt;: &amp;quot;Transition to rust-analyzer as our official LSP (Language Server Protocol) implementation&amp;quot;.
The RFC was accepted with overwhelming support from the community: it is still the most upvoted Rust RFC ever.
However, there was a wrinkle in the plan -- rust-analyzer was not an official Rust project!
That&#x27;s what we are fixing today!&lt;/p&gt;
&lt;p&gt;Next, we will proceed with the plan outlined in the RFC: advertising rust-analyzer as the very likely future of Rust IDE support, gathering feedback, and, conditioned on the positive outcome of that, sunsetting RLS, the currently recommended language server. So, once again -- do try out rust-analyzer and leave feedback on the &lt;a href&#x3D;&quot;https://github.com/rust-analyzer/rust-analyzer/issues/4224&quot;&gt;tracking issues&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;After the transition, we will double down on the technical side of things.&lt;/p&gt;
&lt;p&gt;As exciting as rust-analyzer is today, it only scratches the surface of what&#x27;s possible when you bring the compiler&#x27;s intricate understanding of the code right into the text editor.
The end-game we are aiming for is creating an API to analyze and transform Rust code with full access to semantics.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#funding&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;funding&quot;&gt;&lt;/a&gt;Funding&lt;/h2&gt;
&lt;p&gt;One of the hardest nuts to crack for the present transition was the question of funding.
Today, Rust is organized as a set of somewhat independent projects (rustc, cargo, rustup, rustfmt), and there&#x27;s deliberately no way to fund a specific project directly. The new &lt;a href&#x3D;&quot;https://foundation.rust-lang.org&quot;&gt;Rust Foundation&lt;/a&gt; is the official place to sponsor Rust in general, with the Foundation Board overseeing funds allocation. Yet, it has always been encouraged for individuals to seek individual funding. While the Rust project may advertise funding opportunities for individual contributors, it does not officially &lt;em&gt;endorse&lt;/em&gt; these efforts nor does it facilitate the funding of entire teams.&lt;/p&gt;
&lt;p&gt;rust-analyzer has received a significant share of funds from its OpenCollective and later GitHub Sponsors, managed by Ferrous Systems. This OpenCollective funded efforts by both individual contributors and Ferrous Systems employees. Details of this can be found in their &lt;a href&#x3D;&quot;https://rust-analyzer.github.io/blog/2021/08/03/financial-report-3.html&quot;&gt;transparency reports&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Luckily, the OpenCollective has always been managed in a way that would make it possible to transfer it to a different account holder.
With this transition, the OpenCollective will be renamed from &amp;quot;rust-analyzer OpenCollective&amp;quot; to &amp;quot;Ferrous Systems OpenCollective (rust-analyzer)&amp;quot;. This allows current sponsors to continue to sponsor and also make it clear that their chosen project will continue to be funded.&lt;/p&gt;
&lt;p&gt;In a sense, the OpenCollective is handed to Ferrous Systems. All Sponsor credits will move to &lt;a href&#x3D;&quot;https://ferrous-systems.com/open-source/#sponsors&quot;&gt;https://ferrous-systems.com/open-source/#sponsors&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We would like to thank Ferrous Systems for their openness and flexibility in the process, for their thoughtfulness in making sure the funding situation around rust-analyzer was clear, and for taking on the effort of fundraising.&lt;/p&gt;
&lt;p&gt;Eventually the &lt;a href&#x3D;&quot;https://github.com/sponsors/rust-analyzer&quot;&gt;rust-analyzer GitHub Sponsors&lt;/a&gt; will also move away from the rust-analyzer GitHub organisation.&lt;/p&gt;
&lt;p&gt;And of course, another great way for companies to support rust-analyzer development is to hire &lt;a href&#x3D;&quot;https://github.com/rust-analyzer/rust-analyzer/graphs/contributors&quot;&gt;the people working on rust-analyzer&lt;/a&gt; to continue to do so.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#thanks&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;thanks&quot;&gt;&lt;/a&gt;Thanks&lt;/h2&gt;
&lt;p&gt;We&#x27;d like to once again thank everyone who help get rust-analyzer to this point. From experiment to being well on its way to the officially recommended LSP implementation for Rust, we couldn&#x27;t have done it without the help of our contributors, sponsors, and users.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#conclusion&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;conclusion&quot;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;So that&#x27;s where we are at right now!
Thanks to the awesome contributors to rustc, clippy, cargo, LSP, IntelliJ Rust, RLS and rust-analyzer, Rust today already enjoys great IDE support, even if it still has a bit of experimental flair to it.&lt;/p&gt;
</content>

        <author>
            <name>The rust-analyzer Team on behalf of the entire Rust Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Rust Survey 2021 Results</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/02/15/Rust-Survey-2021.html" type="text/html" title="Rust Survey 2021 Results" />
        <published>2022-02-15T00:00:00+00:00</published>
        <updated>2022-02-15T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/02/15/Rust-Survey-2021.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/02/15/Rust-Survey-2021.html">&lt;p&gt;Greetings Rustaceans!&lt;/p&gt;
&lt;p&gt;Another year has passed, and with it comes another annual Rust survey analysis! The survey was conducted in December 2021.&lt;/p&gt;
&lt;p&gt;Weâ€™d like to thank everyone who participated in this yearâ€™s survey, with a special shout-out to those who helped translate the survey from English into other languages.&lt;/p&gt;
&lt;p&gt;Without further ado, letâ€™s dive into the analysis!&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#a-global-community&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;a-global-community&quot;&gt;&lt;/a&gt;A Global Community&lt;/h2&gt;
&lt;p&gt;The Rust community continues to grow, with this survey having the largest number of complete survey responses (9354 respondents), exceeding last year&#x27;s total by roughly 1500 responses.&lt;/p&gt;
&lt;p&gt;90% of respondents said that they use Rust for any purpose, while 5% stated they had used Rust at some point in the past but no longer do, and 4% stated they have yet to use Rust at all.&lt;/p&gt;
&lt;p&gt;The survey was offered in 10 languages with 78% filling out the survey in English followed by Simplified Chinese (6%), German (4%), and French (3%). Despite English being the language most respondents completed the survey in, respondents hailed from all around the world. The United States was the country with the largest representation at 24% followed by Germany (12%), China (7%), and the U.K. (6%). In total 113 different countries and territories were represented through this survey!&lt;/p&gt;
&lt;p&gt;English, however, is not the language of choice for all Rustaceans with nearly 7% preferring not to use English as a language for technical communication. An additional 23% of respondents prefer another language in addition to English. The most commonly preferred languages (besides English) roughly follow where Rustaceans live with Simplified Chinese, German, and French being the top 3. However, Japanese, Simplified Chinese, and Russian speakers were the most likely to prefer not to use English at all for technical conversation.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#using-rust&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;using-rust&quot;&gt;&lt;/a&gt;Using Rust&lt;/h2&gt;
&lt;p&gt;The percentage of people using Rust continues to rise. Of those using Rust, 81% are currently using it on at least a weekly basis compared to 72% from last year&#x27;s survey.&lt;/p&gt;
&lt;p&gt;75% of all Rust users say they can write production ready code, though 27% say that it is at times a struggle.&lt;/p&gt;
&lt;p&gt;&lt;img src&#x3D;&quot;../../../images/2022-02-RustSurvey/expertise.png&quot; alt&#x3D;&quot;Rust expertise&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Overall, Rustaceans seem to be having a great time writing Rust with only 1% saying it isn&#x27;t fun to use. Only a quarter of a percent find Rust doesn&#x27;t have any real benefit over other programming languages.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#rust-at-work&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;rust-at-work&quot;&gt;&lt;/a&gt;Rust at Work&lt;/h2&gt;
&lt;p&gt;Rust can now safely be classified as a language used by people in professional settings. Of those respondents using Rust, 59% use it at least occasionally at work with 23% using Rust for the majority of their coding. This is a large increase over last year where only 42% of respondents used Rust at work.&lt;/p&gt;
&lt;p&gt;&lt;img src&#x3D;&quot;../../../images/2022-02-RustSurvey/rust-at-work.png&quot; alt&#x3D;&quot;Do you use Rust at work?&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Adopting Rust at work seems to follow a long but ultimately worthwhile path for a lot of Rustaceans. First, 83% of those who have adopted Rust at work found it to be &amp;quot;challenging&amp;quot;. How much this is related to Rust itself versus general challenges with adopting a new programming language, however, is unclear. During adoption only 13% of respondents found the language was slowing their team down and 82% found that Rust helped their teams achieve their goals.&lt;/p&gt;
&lt;p&gt;After adoption, the costs seem to be justified: only 1% of respondents did not find the challenge worth it while 79% said it definitely was. When asked if their teams were likely to use Rust again in the future, 90% agreed. Finally, of respondents using Rust at work, 89% of respondents said their teams found it fun and enjoyable to program.&lt;/p&gt;
&lt;p&gt;As for why respondents are using Rust at work, the top answer was that it allowed users &amp;quot;to build relatively correct and bug free software&amp;quot; with 96% of respondents agreeing with that statement. After correctness, performance (92%) was the next most popular choice. 89% of respondents agreed that they picked Rust at work because of Rust&#x27;s much-discussed security properties.&lt;/p&gt;
&lt;p&gt;&lt;img src&#x3D;&quot;../../../images/2022-02-RustSurvey/rust-adoption.png&quot; alt&#x3D;&quot;Adopting Rust&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Overall, Rust seems to be a language ready for the challenges of production, with only 3% of respondents saying that Rust was a &amp;quot;risky&amp;quot; choice for production use.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#challenges-ahead&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;challenges-ahead&quot;&gt;&lt;/a&gt;Challenges Ahead&lt;/h2&gt;
&lt;p&gt;Overall, the annual survey points towards a growing, healthy community of Rustaceans, but this is not to say we don&#x27;t have work ahead of us. Compile times, a historical focus of improvement for the Rust project, continue to not be where they need to be, with 61% of respondents saying work still needs to be done to improve them. Although, to the compiler team&#x27;s credit, 61% found that they improved over the past year.  Other areas indicated as in need of more improvement were disk space (45%), debugging (40%), and GUI development (56%).&lt;/p&gt;
&lt;p&gt;The IDE experience (led through continued adoption and improvement of various tools like rust-analyzer, IntelliJ Rust, etc.) gets the prize for showing the most improvement:  56% found it has improved over the last year.&lt;/p&gt;
&lt;p&gt;However, compiler error messages received the most praise, with 90% approval of their current state. ðŸŽ‰&lt;/p&gt;
&lt;p&gt;When asked what their biggest worries for the future of Rust are, the top answer was a fear that there will not be enough usage in industry (38%). Given that Rust continues to show strides in adoption at places of work, the community seems to be on a good path to overcoming this concern.&lt;/p&gt;
&lt;p&gt;The next largest concern was that the language would become too complex (33%). This was combined with a relative small number of folks calling for additional features (especially for ones not already in the pipeline).&lt;/p&gt;
&lt;p&gt;Finally, the third largest concern was that those working on Rust would not find the proper support they need to continue to develop the language and community in a healthy way (30%). With the establishment of the Rust Foundation, support structures are coming into place that hopefully will address this point, but no doubt plenty of work is still ahead of us.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#an-exciting-future&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;an-exciting-future&quot;&gt;&lt;/a&gt;An Exciting Future&lt;/h2&gt;
&lt;p&gt;2021 was arguably one of the most significant years in Rust&#x27;s history - with the establishment of the Rust foundation, the 2021 edition, and a larger community than ever, Rust seems to be on a solid path as we head into the future.&lt;/p&gt;
&lt;p&gt;Plenty of work remains, but here&#x27;s hoping for a great 2022!&lt;/p&gt;
</content>

        <author>
            <name>The Rust Survey Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Crates.io Index Snapshot Branches Moving</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/02/14/crates-io-snapshot-branches.html" type="text/html" title="Crates.io Index Snapshot Branches Moving" />
        <published>2022-02-14T00:00:00+00:00</published>
        <updated>2022-02-14T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/02/14/crates-io-snapshot-branches.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/02/14/crates-io-snapshot-branches.html">&lt;p&gt;Every so often, the &lt;a href&#x3D;&quot;https://github.com/rust-lang/crates.io-index&quot;&gt;crates.io index&lt;/a&gt;&#x27;s Git history
is &lt;a href&#x3D;&quot;https://internals.rust-lang.org/t/cargos-crate-index-upcoming-squash-into-one-commit/8440&quot;&gt;squashed into one
commit&lt;/a&gt;
to minimize the history Cargo needs to download. When the index is squashed, we save snapshots
to preserve the history of crate publishes.&lt;/p&gt;
&lt;p&gt;Currently, those snapshots are stored as branches in the main index Git repository. Those branches
are using server resources though, as the server still has to consider their contents whenever
Cargo asks for the master branch. We will be deleting the snapshot branches from this repository to
ensure that all objects referenced in the master branch will only be compressed against other
objects in the master branch, ensuring that the current clone behavior will be much more efficient
on the server side.&lt;/p&gt;
&lt;p&gt;Here&#x27;s how this might affect you:&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#if-you-use-cargo&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;if-you-use-cargo&quot;&gt;&lt;/a&gt;If you use Cargo&lt;/h2&gt;
&lt;p&gt;You should not see any effects from this change. Cargo does not use the snapshot branches, and
Cargo regularly handles index squashes. If you do see any issues, they are bugs, please &lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo&quot;&gt;report
them on the Cargo repo&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#if-you-use-the-snapshot-branches&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;if-you-use-the-snapshot-branches&quot;&gt;&lt;/a&gt;If you use the snapshot branches&lt;/h2&gt;
&lt;p&gt;In one week, on 2022-02-21, we will be removing all snapshot branches from the crates.io-index
repo. All snapshot branches, both historical and in the future, are and will be in the
&lt;a href&#x3D;&quot;https://github.com/rust-lang/crates.io-index-archive&quot;&gt;rust-lang/crates.io-index-archive repo&lt;/a&gt;
instead. Please update any scripts or tools referencing the snapshot branches by that time.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#in-the-future&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;in-the-future&quot;&gt;&lt;/a&gt;In the future&lt;/h2&gt;
&lt;p&gt;In the medium term, we&#x27;re working to prioritize the completion of &lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo/issues/9069&quot;&gt;in-progress
work&lt;/a&gt; to add a way to serve the index as static
files on HTTP, which will further ease the server load. The index repository will &lt;em&gt;not&lt;/em&gt; be going
away so that older versions of Cargo will continue to work. See &lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/pull/2789&quot;&gt;RFC
2789&lt;/a&gt; for more details.&lt;/p&gt;
</content>

        <author>
            <name>The Crates.io Team</name>
        </author>
    </entry>
    
</feed>

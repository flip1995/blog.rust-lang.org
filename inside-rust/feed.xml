<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <generator uri="https://blog.rust-lang.org/inside-rust/" version="0.1.0">Inside Rust Blog</generator>
    <link href="https://blog.rust-lang.org/inside-rust/feed.xml" rel="self" type="application/atom+xml" />
    <link href="https://blog.rust-lang.org/inside-rust/" rel="alternate" type="text/html" />
    <id>https://blog.rust-lang.org/inside-rust/</id>
    <title>Inside Rust Blog</title>
    <subtitle>Want to follow along with Rust development? Curious how you might get involved? Take a look!</subtitle>
    <author>
        <name>Maintained by the Rust Teams.</name>
        <uri>https://github.com/rust-lang/blog.rust-lang.org/</uri>
    </author>
    <updated>2019-10-22T17:46:15Z</updated>

    
    <entry>
        <title>Announcing the LLVM ICE-breaker group</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/10/22/LLVM-ICE-breakers.html" type="text/html" title="Announcing the LLVM ICE-breaker group" />
        <published>2019-10-22T00:00:00Z</published>
        <updated>2019-10-22T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/10/22/LLVM-ICE-breakers.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/10/22/LLVM-ICE-breakers.html">&lt;p&gt;Today I'm announcing a new experiment in the compiler team, the &lt;strong&gt;LLVM ICE-breaker group&lt;/strong&gt;. If you're familiar with LLVM and would like to contribute to rustc -- but without taking on a large commitment -- then the LLVM ICE-breaker group might well be for you!&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#what-is-the-llvm-ice-breaker-group&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;what-is-the-llvm-ice-breaker-group&quot;&gt;&lt;/a&gt;What is the LLVM ICE-breaker group?&lt;/h3&gt;
&lt;p&gt;At its heart, the LLVM ICE-breaker group is just a list of people who would like to be notified when we come across LLVM bugs. You can add yourself to this list very easily -- just &lt;a href=&quot;https://rust-lang.github.io/rustc-guide/ice-breaker/about.html#join&quot;&gt;open a PR&lt;/a&gt;! When we come across a suitable bug, we'll write a message that &lt;code&gt;@&lt;/code&gt;-mentions every Github user on that list. If you have some time, maybe you can fix one of them, or at least offer some words of wisdom to help somebody else figure out what's going on.&lt;/p&gt;
&lt;p&gt;There are a few other things associated with the group too, however. For example, we've got a &lt;a href=&quot;https://rust-lang.github.io/rustc-guide/ice-breaker/llvm.html&quot;&gt;guide&lt;/a&gt; that offers some tips for how to fix LLVM-related bugs and may help you get started (particularly if you're not that familiar with rustc).&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#what-kind-of-bugs-are-we-talking-about&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;what-kind-of-bugs-are-we-talking-about&quot;&gt;&lt;/a&gt;What kind of bugs are we talking about?&lt;/h3&gt;
&lt;p&gt;The goal is to identify &amp;quot;self-contained&amp;quot; bugs that are unlikely to require large-scale compiler refactorings or to get entangled in other big projects.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#who-should-join&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;who-should-join&quot;&gt;&lt;/a&gt;Who should join?&lt;/h3&gt;
&lt;p&gt;This group is a great fit for anyone who is familiar with LLVM and who would like to learn more about Rust or to get more involved in the Rust project. Even if you don't have time to open PRs against rustc, there are many other ways to help:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;identifying open LLVM bugs that we may be running into;&lt;/li&gt;
&lt;li&gt;reducing Rust sources to minimal reducers;&lt;/li&gt;
&lt;li&gt;reducing LLVM IR to minimal problem cases;&lt;/li&gt;
&lt;li&gt;and so forth.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(For that matter, feel freeo to join the group even if you're &lt;em&gt;not&lt;/em&gt; all that familiar with LLVM -- no better way to learn!)&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#whats-with-the-name-ice-breaker-anyway?&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-with-the-name-ice-breaker-anyway?&quot;&gt;&lt;/a&gt;What's with the name ICE-breaker anyway?&lt;/h3&gt;
&lt;p&gt;An &amp;quot;ICE&amp;quot; is an &amp;quot;internal compiler error&amp;quot;. It actually refers specifically to the case where the compiler panics (which tends to be an easy sort of bug to fix). In fact, very few LLVM bugs cause real ICEs, but the name was too good to pass up.&lt;/p&gt;
&lt;p&gt;But of course we also hope that these ICE-breaker groups can help people to get more acquainted with hacking on rustc; to &lt;a href=&quot;https://en.wiktionary.org/wiki/break_the_ice&quot;&gt;&amp;quot;break the ice&amp;quot;&lt;/a&gt;, if you will (ha! I kill me).&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#will-there-be-more-ice-breaker-groups&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;will-there-be-more-ice-breaker-groups&quot;&gt;&lt;/a&gt;Will there be more ICE-breaker groups?&lt;/h3&gt;
&lt;p&gt;I certainly hope so! As I mentioned before, this is an experiment, but presuming that it works out well we fully intend to create more ICE-breaker groups.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#so-how-do-i-sign-up-again&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;so-how-do-i-sign-up-again&quot;&gt;&lt;/a&gt;So how do I sign up again?&lt;/h3&gt;
&lt;p&gt;Easy! Just &lt;a href=&quot;https://rust-lang.github.io/rustc-guide/ice-breaker/about.html#join&quot;&gt;open a PR&lt;/a&gt;!&lt;/p&gt;
</content>

        <author>
            <name>Niko Matsakis</name>
        </author>
    </entry>
    
    <entry>
        <title>2019-10-17 Compiler Team Triage Meeting</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/10/21/compiler-team-meeting.html" type="text/html" title="2019-10-17 Compiler Team Triage Meeting" />
        <published>2019-10-21T00:00:00Z</published>
        <updated>2019-10-21T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/10/21/compiler-team-meeting.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/10/21/compiler-team-meeting.html">&lt;p&gt;The compiler team had our weekly triage meeting on 2019-10-17.
You can find the &lt;a href=&quot;https://rust-lang.github.io/compiler-team/minutes/triage-meeting/2019-10-17/&quot;&gt;minutes&lt;/a&gt; on the &lt;a href=&quot;https://github.com/rust-lang/compiler-team&quot;&gt;compiler-team&lt;/a&gt; repository.
Each week, we have general announcements from the team followed by check-ins from two of the compiler team working groups.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#announcements&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;announcements&quot;&gt;&lt;/a&gt;Announcements&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Design meeting on &lt;a href=&quot;https://github.com/rust-lang/compiler-team/issues/186&quot;&gt;debuginfo strategy&lt;/a&gt; tomorrow (2019-10-18) on Zulip.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/design.20meeting.202019-10-18/near/178476377&quot;&gt;Link to full meeting&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The traits working group had a &lt;a href=&quot;https://github.com/rust-lang/wg-traits/tree/master/minutes&quot;&gt;design meeting&lt;/a&gt; yesterday on lazy normalization.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/nikomatsakis&quot;&gt;@nikomatsakis&lt;/a&gt; has been looking into lazy normalization specifically for constants and hopes to have some notes to share soon.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The LLVM ICE-breakers working group is nearly ready to go live.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/spastorino&quot;&gt;@spastorino&lt;/a&gt; has nearly finished interning &lt;code&gt;Place&lt;/code&gt; projections which is an incremental step to MIR 2.0.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/centril&quot;&gt;@centril&lt;/a&gt; is continuing to work on splitting &lt;code&gt;libsyntax&lt;/code&gt; apart which will decrease the amount of code &lt;code&gt;librustc&lt;/code&gt; depends on.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;#working-group-sync&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;working-group-sync&quot;&gt;&lt;/a&gt;Working group sync&lt;/h2&gt;
&lt;h3&gt;&lt;a href=&quot;#wg-mir-opt&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;wg-mir-opt&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://rust-lang.github.io/compiler-team/working-groups/mir-opt/&quot;&gt;wg-mir-opt&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/wesleywiser&quot;&gt;@wesleywiser&lt;/a&gt; Moved promoted MIR out of &lt;code&gt;mir::Body&lt;/code&gt; &lt;a href=&quot;https://github.com/rust-lang/rust/pull/63580&quot;&gt;#63580&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/wesleywiser&quot;&gt;@wesleywiser&lt;/a&gt; Reimplemented the &lt;code&gt;ConstProp&lt;/code&gt; optimization pass on top of the existing const eval code &lt;a href=&quot;https://github.com/rust-lang/rust/pull/64419&quot;&gt;#64419&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/spastorino&quot;&gt;@spastorino&lt;/a&gt; Converted &lt;code&gt;mir::Place&lt;/code&gt; to no longer be a recursive data structure &lt;a href=&quot;https://github.com/rust-lang/rust/pull/63420&quot;&gt;#63420&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;There is ongoing work in both const prop and place refactorings.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We've figured out a plan for &amp;quot;weird&amp;quot; place projections like dereferences (virtual locals).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/weekly.20meeting.202019-10-17.20.2354818/near/178389131&quot;&gt;Link to full conversation&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#wg-meta&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;wg-meta&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://rust-lang.github.io/compiler-team/working-groups/meta/&quot;&gt;wg-meta&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The &lt;a href=&quot;https://blog.rust-lang.org/inside-rust/index.html&quot;&gt;Inside Rust&lt;/a&gt; blog has launched.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &lt;a href=&quot;https://rust-lang.github.io/rustc-guide/ice-breaker/about.html&quot;&gt;ICE-Breaker group&lt;/a&gt; has been formed!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &lt;a href=&quot;https://rust-lang.github.io/rustc-guide/ice-breaker/llvm.html&quot;&gt;LLVM ICE-Breaker group&lt;/a&gt; is also being formed.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/weekly.20meeting.202019-10-17.20.2354818/near/178389266&quot;&gt;Link to full conversation&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>Wesley Wiser</name>
        </author>
    </entry>
    
    <entry>
        <title>Please welcome ecstatic-morse to compiler-contributors</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/10/17/ecstatic-morse-for-compiler-contributors.html" type="text/html" title="Please welcome ecstatic-morse to compiler-contributors" />
        <published>2019-10-17T00:00:00Z</published>
        <updated>2019-10-17T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/10/17/ecstatic-morse-for-compiler-contributors.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/10/17/ecstatic-morse-for-compiler-contributors.html">&lt;p&gt;Please welcome &lt;a href=&quot;https://github.com/ecstatic-morse&quot;&gt;@ecstatic-morse&lt;/a&gt; to the &lt;a href=&quot;https://rust-lang.github.io/rfcs/2689-compiler-team-contributors.html&quot;&gt;compiler contributors&lt;/a&gt; group!
They're working to make compile-time evaluation more expressive by
enabling &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;match&lt;/code&gt; and other control flow in constants. As one of
their first major contributions, they implemented a dataflow analysis
to validate the bodies of &lt;code&gt;const&lt;/code&gt;s and &lt;code&gt;const fn&lt;/code&gt;s
(&lt;a href=&quot;https://github.com/rust-lang/rust/pull/64470&quot;&gt;rust-lang/rust#64470&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Congratulations &lt;a href=&quot;https://github.com/ecstatic-morse&quot;&gt;@ecstatic-morse&lt;/a&gt;, and thanks!&lt;/p&gt;
</content>

        <author>
            <name>Niko Matsakis</name>
        </author>
    </entry>
    
    <entry>
        <title>2019-10-10 Infrastructure Team Meeting</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/10/15/infra-team-meeting.html" type="text/html" title="2019-10-10 Infrastructure Team Meeting" />
        <published>2019-10-15T00:00:00Z</published>
        <updated>2019-10-15T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/10/15/infra-team-meeting.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/10/15/infra-team-meeting.html">&lt;p&gt;Meeting run by kennytm. Minutes written by pietroalbini.&lt;br /&gt;
Attending: alexcrichton, kennytm, Mark-Simulacrum, pietroalbini, sgrif,
shepmaster&lt;br /&gt;
&lt;a href=&quot;https://discordapp.com/channels/442252698964721669/443148319431065610/633710764762464285&quot;&gt;Start of the conversation&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#publishing-the-meeting-minutes-pietroalbini)&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;publishing-the-meeting-minutes-pietroalbini)&quot;&gt;&lt;/a&gt;Publishing the meeting minutes (pietroalbini)&lt;/h2&gt;
&lt;p&gt;The infrastructure team recently started keeping minutes of the meetings (these
ones!), recording everything we decided and what the rationale of the decision
was. The original minutes are stored in a private Paper document, as they also
contain minutes of the private parts of the meetings.&lt;/p&gt;
&lt;p&gt;pietroalbini proposed to store a public version of the minutes (with the
private parts removed) on the
&lt;a href=&quot;https://github.com/rust-lang/infra-team&quot;&gt;infra-team&lt;/a&gt; repository, and to
cross-post them on the &lt;a href=&quot;https://blog.rust-lang.org/inside-rust&quot;&gt;“Inside Rust”&lt;/a&gt;
blog. The rest of the team agreed on this. pietroalbini also volunteered to
make the work of writing the minutes and publishing them.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#binary-signing-and-the-signpath-offer-pietroalbini)&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;binary-signing-and-the-signpath-offer-pietroalbini)&quot;&gt;&lt;/a&gt;Binary signing and the SignPath offer (pietroalbini)&lt;/h2&gt;
&lt;p&gt;A few weeks ago the team received an email from SignPath offering code signing
certificates and infrastructure to the Rust project. The main concern team
members had was the lack of time to implement the changes on our end, as
everyone is busy with other tasks. Everyone agreed to revisit the topic and
their offer once someone inside the team has time to drive the implementation
effort.&lt;/p&gt;
</content>

        <author>
            <name>Pietro Albini</name>
        </author>
    </entry>
    
    <entry>
        <title>2019-10-10 Compiler Team Triage Meeting</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/10/15/compiler-team-meeting.html" type="text/html" title="2019-10-10 Compiler Team Triage Meeting" />
        <published>2019-10-15T00:00:00Z</published>
        <updated>2019-10-15T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/10/15/compiler-team-meeting.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/10/15/compiler-team-meeting.html">&lt;p&gt;The compiler team had our weekly triage meeting on 2019-10-10.
You can find the &lt;a href=&quot;https://rust-lang.github.io/compiler-team/minutes/triage-meeting/2019-10-10/&quot;&gt;minutes&lt;/a&gt; on the &lt;a href=&quot;https://github.com/rust-lang/compiler-team&quot;&gt;compiler-team&lt;/a&gt; repository.
Each week, we have general announcements from the team followed by check-ins from two of the compiler team working groups.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#announcements&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;announcements&quot;&gt;&lt;/a&gt;Announcements&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/centril&quot;&gt;@centril&lt;/a&gt; is splitting &lt;code&gt;libsyntax&lt;/code&gt; into data and logic parts which will decrease the amount of code &lt;code&gt;librustc&lt;/code&gt; depends on.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/nagisa&quot;&gt;@nagisa&lt;/a&gt; is working on a cross-platform version of stacker which will allow us to avoid stack overflows in rustc.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;There is a compiler team &lt;a href=&quot;https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-10-11-DepGraph-persistence-PR62038/&quot;&gt;design meeting&lt;/a&gt; scheduled for tomorrow (2019-10-11) to discuss some of &lt;a href=&quot;https://github.com/zoxc&quot;&gt;@Zoxc&lt;/a&gt;'s PRs.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/pnkfelix&quot;&gt;@pnkfelix&lt;/a&gt; is revising the code that handles structural match checking.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/nikomatsakis&quot;&gt;@nikomatsakis&lt;/a&gt; has a PR (&lt;a href=&quot;https://github.com/rust-lang/rust/issues/65232&quot;&gt;#65232&lt;/a&gt;) up which helps us get closer to lazy normalization.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;wg-traits&lt;/code&gt; is going to start holding a weekly &amp;quot;office hours&amp;quot; video call to help answer questions and teach people about trait system internals.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;#working-group-sync&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;working-group-sync&quot;&gt;&lt;/a&gt;Working group sync&lt;/h2&gt;
&lt;h3&gt;&lt;a href=&quot;#wg-learning&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;wg-learning&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://rust-lang.github.io/compiler-team/working-groups/learning/&quot;&gt;wg-learning&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;wg-learning&lt;/code&gt; aims to make the compiler easier to learn by ensuring that rustc-guide and api docs are “complete”.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;wg-learning&lt;/code&gt; has been working on transcribing videos from the &lt;a href=&quot;https://www.youtube.com/watch?v=elBxMRSNYr4&amp;list=PL85XCvVPmGQhOL-J2Ng7qlPvDVOwYpGTN&quot;&gt;compiler lecture series&lt;/a&gt; into &lt;a href=&quot;https://rust-lang.github.io/rustc-guide/&quot;&gt;rustc-guide&lt;/a&gt; chapters.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Originally, individuals were assigned one or lectures to complete but that hasn't worked very well.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Recently, they're trying to work on one video at a time as a team with much better results.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;There's &lt;a href=&quot;https://paper.dropbox.com/doc/Ty-lecture-summary--Almbjo_id6n8CKrOHlsTMG2dAg-4jFj9bVOLlW7uhIOWHITX&quot;&gt;a PR&lt;/a&gt; open for a new chapter based on the &lt;code&gt;ty&lt;/code&gt; lecture.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/weekly.20meeting.202019-10-10.20.2354818/near/177816515&quot;&gt;Link to full discussion&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#wg-llvm&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;wg-llvm&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://rust-lang.github.io/compiler-team/working-groups/llvm/&quot;&gt;wg-llvm&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;wg-llvm&lt;/code&gt; encompasses work in LLVM upstream fixing the issues and implementing features that matter to Rust.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;rustc has upgraded to the LLVM 9 release;
&lt;ul&gt;
&lt;li&gt;Which allows us to replace some the emscripten stuff with LLVM’s toolchain.&lt;/li&gt;
&lt;li&gt;As part of these upgrades we will likely end up dropping support for the super old LLVM 6, which in turn allows us to stop building the unnecessary Go &amp;amp; OCaml bindings to LLVM, which in turn helps rustc build times slightly.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;People are also working on enabling use of the new pass manager, which might give us some tangible code quality improvements over the status quo.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/weekly.20meeting.202019-10-10.20.2354818/near/177817116&quot;&gt;Link to full discussion&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>Wesley Wiser</name>
        </author>
    </entry>
    
    <entry>
        <title>2019-10-10 Lang Team Triage Meeting</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/10/11/Lang-Team-Meeting.html" type="text/html" title="2019-10-10 Lang Team Triage Meeting" />
        <published>2019-10-11T00:00:00Z</published>
        <updated>2019-10-11T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/10/11/Lang-Team-Meeting.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/10/11/Lang-Team-Meeting.html">&lt;p&gt;We had our &lt;a href=&quot;https://github.com/rust-lang/lang-team/#meeting-calendara&quot;&gt;weekly triage meeting&lt;/a&gt; on 2019-10-10. You can find the
&lt;a href=&quot;https://github.com/rust-lang/lang-team/blob/master/minutes/2019-10-10.md&quot;&gt;minutes&lt;/a&gt; on the &lt;a href=&quot;https://github.com/rust-lang/lang-team/&quot;&gt;lang-team&lt;/a&gt; repository; there is also a &lt;a href=&quot;https://youtu.be/QvE9-zce5_4&quot;&gt;video
recording&lt;/a&gt; on YouTube. This week we had a number of folks who have
been working on const evaluation in attendance, which gave us an
opportunity to dive into some of the complexities involved there. We
also discussed how to make the const evaluation effort into a
&amp;quot;shepherded project&amp;quot;, a concept that we are still actively developing
(see my blog post on &lt;a href=&quot;http://smallcultfollowing.com/babysteps/blog/2019/09/11/aic-shepherds-3-0/&quot;&gt;Shepherding 3.0&lt;/a&gt; for the general idea).&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#other-updates-on-shepherded-items&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;other-updates-on-shepherded-items&quot;&gt;&lt;/a&gt;Other updates on shepherded items&lt;/h2&gt;
&lt;p&gt;This is our current list of &amp;quot;shepherded items&amp;quot;, which are things we
are tracking week to week. We're still evolving the shepherding
system. Hopefully we'll soon have links for all of these to a good,
representative place that explains the overall status and roadmap. All
in good time.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/nikomatsakis/project-ffi-unwind&quot;&gt;unwind-ffi&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;created a &lt;a href=&quot;http://smallcultfollowing.com/babysteps/blog/2019/09/11/aic-shepherds-3-0/&quot;&gt;zulip&lt;/a&gt; stream (&lt;code&gt;#wg-ffi-unwind&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;preparing an RFC that creates the group official and lays out the roadmap&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&amp;quot;object safety&amp;quot; group (e.g., &lt;a href=&quot;http://smallcultfollowing.com/babysteps/blog/2019/09/11/aic-shepherds-3-0/&quot;&gt;#57893&lt;/a&gt;)
&lt;ul&gt;
&lt;li&gt;no major updates, still iterating on the &amp;quot;in progress&amp;quot; branch&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;re-rebalance coherence
&lt;ul&gt;
&lt;li&gt;we have a spreadsheet mapping out all the possible tests&lt;/li&gt;
&lt;li&gt;we'll fill out the matrix, but probably ready to stabilize 🎉&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;stabilize proc-macros generating macro-rules items
&lt;ul&gt;
&lt;li&gt;waiting on a report from pnkfelix&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;grammar working group
&lt;ul&gt;
&lt;li&gt;no updates&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>

        <author>
            <name>Niko Matsakis</name>
        </author>
    </entry>
    
    <entry>
        <title>Improving async-await's &quot;Future is not Send&quot; diagnostic</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/10/11/AsyncAwait-Not-Send-Error-Improvements.html" type="text/html" title="Improving async-await's &quot;Future is not Send&quot; diagnostic" />
        <published>2019-10-11T00:00:00Z</published>
        <updated>2019-10-11T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/10/11/AsyncAwait-Not-Send-Error-Improvements.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/10/11/AsyncAwait-Not-Send-Error-Improvements.html">&lt;p&gt;Async-await is due to hit stable in the 1.39 release (only a month away!), and as announced in the
&lt;a href=&quot;https://blog.rust-lang.org/inside-rust/2019/10/07/AsyncAwait-WG-Focus-Issues.html&quot;&gt;&amp;quot;Async Foundations Update: Time for polish!&amp;quot;&lt;/a&gt; post last month, the Async
Foundations WG has shifted its focus to polish. This post will highlight one aspect of that
focus, diagnostic improvements, and in particular, the improvements that the working group has
been making to the once-unhelpful &amp;quot;future is not send&amp;quot; diagnostic.&lt;/p&gt;
&lt;h1&gt;&lt;a href=&quot;#why-doesnt-my-future-implement-send?&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;why-doesnt-my-future-implement-send?&quot;&gt;&lt;/a&gt;Why doesn't my future implement &lt;code&gt;Send&lt;/code&gt;?&lt;/h1&gt;
&lt;p&gt;One of the major places where async-await should be a pleasure to use is in multithreaded contexts,
where having a future that can be sent to other threads is desirable. This might look something
like the following (for brevity, there aren't any threads here, just a requirement that the
future implement &lt;code&gt;std::marker::Send&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;use std::sync::{Mutex, MutexGuard};

fn is_send&amp;lt;T: Send&amp;gt;(t: T) { }

async fn foo() {
    bar(&amp;amp;Mutex::new(22)).await
}

async fn bar(x: &amp;amp;Mutex&amp;lt;u32&amp;gt;) {
    let g = x.lock().unwrap();
    baz().await
}

async fn baz() { }

fn main() {
    is_send(foo());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we try to compile this, we'll get an unwieldly and hard-to-follow diagnostic:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error[E0277]: `std::sync::MutexGuard&amp;lt;'_, u32&amp;gt;` cannot be sent between threads safely
  --&amp;gt; src/main.rs:23:5
   |
23 |     is_send(foo());
   |     ^^^^^^^ `std::sync::MutexGuard&amp;lt;'_, u32&amp;gt;` cannot be sent between threads safely
   |
   = help: within `impl std::future::Future`, the trait `std::marker::Send` is not implemented for `std::sync::MutexGuard&amp;lt;'_, u32&amp;gt;`
   = note: required because it appears within the type `for&amp;lt;'r, 's&amp;gt; {&amp;amp;'r std::sync::Mutex&amp;lt;u32&amp;gt;, std::sync::MutexGuard&amp;lt;'s, u32&amp;gt;, impl std::future::Future, ()}`
   = note: required because it appears within the type `[static generator@src/main.rs:13:30: 16:2 x:&amp;amp;std::sync::Mutex&amp;lt;u32&amp;gt; for&amp;lt;'r, 's&amp;gt; {&amp;amp;'r std::sync::Mutex&amp;lt;u32&amp;gt;, std::sync::MutexGuard&amp;lt;'s, u32&amp;gt;, impl std::future::Future, ()}]`
   = note: required because it appears within the type `std::future::GenFuture&amp;lt;[static generator@src/main.rs:13:30: 16:2 x:&amp;amp;std::sync::Mutex&amp;lt;u32&amp;gt; for&amp;lt;'r, 's&amp;gt; {&amp;amp;'r std::sync::Mutex&amp;lt;u32&amp;gt;, std::sync::MutexGuard&amp;lt;'s, u32&amp;gt;, impl std::future::Future, ()}]&amp;gt;`
   = note: required because it appears within the type `impl std::future::Future`
   = note: required because it appears within the type `impl std::future::Future`
   = note: required because it appears within the type `for&amp;lt;'r&amp;gt; {impl std::future::Future, ()}`
   = note: required because it appears within the type `[static generator@src/main.rs:9:16: 11:2 for&amp;lt;'r&amp;gt; {impl std::future::Future, ()}]`
   = note: required because it appears within the type `std::future::GenFuture&amp;lt;[static generator@src/main.rs:9:16: 11:2 for&amp;lt;'r&amp;gt; {impl std::future::Future, ()}]&amp;gt;`
   = note: required because it appears within the type `impl std::future::Future`
   = note: required because it appears within the type `impl std::future::Future`
note: required by `is_send`
  --&amp;gt; src/main.rs:5:1
   |
5  | fn is_send&amp;lt;T: Send&amp;gt;(t: T) {
   | ^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That's.. not great. Let's break down what's happening and understand what this error is trying to
tell us.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn main() {
    is_send(foo());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In &lt;code&gt;main&lt;/code&gt;, we are calling &lt;code&gt;foo&lt;/code&gt; and passing the return value to &lt;code&gt;is_send&lt;/code&gt;. &lt;code&gt;foo&lt;/code&gt; is an &lt;code&gt;async fn&lt;/code&gt;,
so it doesn't return &lt;code&gt;()&lt;/code&gt; (what you might expect for a function with no return type specified).
Instead, it returns &lt;code&gt;impl std::future::Future&amp;lt;Output = ()&amp;gt;&lt;/code&gt;, some unnamed type that implements
&lt;code&gt;std::future::Future&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;async fn foo() {
    bar(&amp;amp;Mutex::new(22)).await
}

// becomes...

fn foo() -&amp;gt; impl std::future::Future&amp;lt;Output = ()&amp;gt; {
    async move {
        bar(&amp;amp;Mutex::new(22)).await
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you want to learn more about the transformations that happen with async-await, consider
reading the &lt;a href=&quot;https://rust-lang.github.io/async-book/01_getting_started/04_async_await_primer.html&quot;&gt;&lt;code&gt;async&lt;/code&gt;/&lt;code&gt;.await&lt;/code&gt; primer chapter of the async book&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn is_send&amp;lt;T: Send&amp;gt;(t: T) { }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It looks like the error we're getting is because the future returned by &lt;code&gt;foo&lt;/code&gt; doesn't satisfy
the &lt;code&gt;T: Send&lt;/code&gt; bound of &lt;code&gt;is_send&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#how-are-async-functions-implemented&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;how-are-async-functions-implemented&quot;&gt;&lt;/a&gt;How are async functions implemented?&lt;/h2&gt;
&lt;p&gt;To explain why our future doesn't implement &lt;code&gt;Send&lt;/code&gt;, we first need to understand a little bit more
about what async-await is doing under the hood. rustc implements &lt;code&gt;async fn&lt;/code&gt;s using generators,
an unstable language feature for resumable functions like the co-routines you might be familiar
with from other languages. Generators are laid out like enums with variants containing all of the
variables that are used across await points (which desugar to generator yields):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;async fn bar(x: &amp;amp;Mutex&amp;lt;u32&amp;gt;) {
    let g = x.lock().unwrap();
    baz().await // &amp;lt;- await point (suspend #0), `g` and `x` are in use before await point
} // &amp;lt;- `g` and `x` dropped here, after await point
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;enum BarGenerator {
    // `bar`'s parameters.
    Unresumed { x: &amp;amp;Mutex&amp;lt;u32&amp;gt; },

    Suspend0 {
        // Future returned by `baz`, which is being polled.
        baz_future: BazGenerator,

        // Locals that are used across the await point.
        x: &amp;amp;Mutex&amp;lt;u32&amp;gt;,
        g: MutexGuard&amp;lt;'_, u32&amp;gt;,
    },

    Returned { value: () }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you want to learn more about the &lt;code&gt;async fn&lt;/code&gt; implementation details, then Tyler Mandry has
written &lt;a href=&quot;https://tmandry.gitlab.io/blog/posts/optimizing-await-1/&quot;&gt;an excellent blog post&lt;/a&gt; diving into their work here in more depth which is
definitely worth a read.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#so-why-doesn't-my-future-implement-send?&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;so-why-doesn't-my-future-implement-send?&quot;&gt;&lt;/a&gt;So, why doesn't my future implement &lt;code&gt;Send&lt;/code&gt;?&lt;/h2&gt;
&lt;p&gt;We now know that an &lt;code&gt;async fn&lt;/code&gt; is represented like an enum behind-the-scenes. In synchronous Rust,
you'll be used to your types automatically implementing &lt;code&gt;Send&lt;/code&gt; when the
&lt;a href=&quot;https://doc.rust-lang.org/std/marker/trait.Send.html&quot;&gt;compiler determines it's appropriate&lt;/a&gt; - typically when all of the fields of your type
also implement &lt;code&gt;Send&lt;/code&gt;. It follows that the enum-like that represents our &lt;code&gt;async fn&lt;/code&gt; would
implement &lt;code&gt;Send&lt;/code&gt; if all of the types in it do.&lt;/p&gt;
&lt;p&gt;In other words, a future is safe to send across threads if all of the types that are held across
&lt;code&gt;.await&lt;/code&gt; points implement &lt;code&gt;Send&lt;/code&gt;. This behaviour is useful because it lets us write generic code
that interoperates smoothly with async-await, but without diagnostic support we get confusing error
messages.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#well-which-type-is-the-problem-in-the-example?&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;well-which-type-is-the-problem-in-the-example?&quot;&gt;&lt;/a&gt;Well, which type is the problem in the example?&lt;/h2&gt;
&lt;p&gt;Returning to our example, the future must be holding a type across an &lt;code&gt;.await&lt;/code&gt; point that doesn't
implement &lt;code&gt;Send&lt;/code&gt;, but where? This is the primary question that the diagnostic improvement aims to
help answer. Let's start by looking at &lt;code&gt;foo&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;async fn foo() {
    bar(&amp;amp;Mutex::new(22)).await
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;foo&lt;/code&gt; invokes &lt;code&gt;bar&lt;/code&gt;, passing a reference to a &lt;code&gt;std::sync::Mutex&lt;/code&gt; and getting a future back, before
&lt;code&gt;await&lt;/code&gt;ing it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;async fn bar(x: &amp;amp;Mutex&amp;lt;u32&amp;gt;) {
    let g: MutexGuard&amp;lt;u32&amp;gt; = x.lock().unwrap();
    baz().await
} // &amp;lt;- `g` is dropped here
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;bar&lt;/code&gt; locks the mutex before &lt;code&gt;await&lt;/code&gt;ing &lt;code&gt;baz&lt;/code&gt;. &lt;code&gt;std::sync::MutexGuard&amp;lt;u32&amp;gt;&lt;/code&gt; does not implement
&lt;code&gt;Send&lt;/code&gt; and lives across the &lt;code&gt;baz().await&lt;/code&gt; point (because &lt;code&gt;g&lt;/code&gt; is dropped at the end of the scope)
which causes the entire future not to implement &lt;code&gt;Send&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;That wasn't obvious from the error: we had to know that futures might implement &lt;code&gt;Send&lt;/code&gt; depending
on the types they capture &lt;em&gt;and&lt;/em&gt; find the type which lives across an await point ourselves.&lt;/p&gt;
&lt;p&gt;Fortunately, the Async Foundations WG has been working to improve this error, and
&lt;a href=&quot;https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=7e80a8bc151df8817e0983e55bf2667a&quot;&gt;in nightly&lt;/a&gt;, we see the following diagnostic instead:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error[E0277]: `std::sync::MutexGuard&amp;lt;'_, u32&amp;gt;` cannot be sent between threads safely
  --&amp;gt; src/main.rs:23:5
   |
5  | fn is_send&amp;lt;T: Send&amp;gt;(t: T) {
   |    -------    ---- required by this bound in `is_send`
...
23 |     is_send(foo());
   |     ^^^^^^^ `std::sync::MutexGuard&amp;lt;'_, u32&amp;gt;` cannot be sent between threads safely
   |
   = help: within `impl std::future::Future`, the trait `std::marker::Send` is not implemented for `std::sync::MutexGuard&amp;lt;'_, u32&amp;gt;`
note: future does not implement `std::marker::Send` as this value is used across an await
  --&amp;gt; src/main.rs:15:3
   |
14 |   let g = x.lock().unwrap();
   |       - has type `std::sync::MutexGuard&amp;lt;'_, u32&amp;gt;`
15 |   baz().await;
   |   ^^^^^^^^^^^ await occurs here, with `g` maybe used later
16 | }
   | - `g` is later dropped here
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Much better!&lt;/p&gt;
&lt;h1&gt;&lt;a href=&quot;#how-does-it-work&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;how-does-it-work&quot;&gt;&lt;/a&gt;How does it work?&lt;/h1&gt;
&lt;p&gt;When rustc's trait system determines that a trait wasn't implemented, in this case
&lt;code&gt;std::marker::Send&lt;/code&gt;, it emits this error. The trait system produces a chain of &amp;quot;obligations&amp;quot;.
Obligations are types which denote where a bound (e.g &lt;code&gt;T: Send&lt;/code&gt; in &lt;code&gt;is_send&lt;/code&gt;) originated,
or where a bound was propagated.&lt;/p&gt;
&lt;p&gt;To improve this diagnostic, the chain of obligations is now treated like a stack frame, where
each &amp;quot;frame&amp;quot; of obligations represents each function's contribution to the error. Let's make
that more concrete with a very rough approximation:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;Obligation {
    kind: DerivedObligation(/* generator that captured `g` */),
    source: /* `Span` type pointing at `bar`'s location in user code */,
    parent: Some(Obligation {
        kind: DerivedObligation(/* generator calling `bar` */),
        source: /* `Span` type pointing at `foo`'s location in user code */,
        parent: Some(Obligation {
            kind: ItemObligation(/* type representing `std::marker::Send` */),
            source: /* `Span` type pointing at `is_send`'s location in user code */,
            cause: None,
        }),
    }),
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The compiler matches against the chain expecting an &lt;code&gt;ItemObligation&lt;/code&gt; and some &lt;code&gt;DerivedObligation&lt;/code&gt;s
containing generators, which identifies the error we want to improve. Using information from these
obligations, rustc can construct the specialized error shown above - if you'd like to see what the
actual implementation looks like, check out PR &lt;a href=&quot;https://github.com/rust-lang/rust/pull/64895&quot;&gt;#64895&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you're interested in improving diagnostics like this, or even just fixing bugs, consider
contributing to the compiler! There are many working groups to join and resources to help you get
started (like the &lt;a href=&quot;https://rust-lang.github.io/rustc-guide&quot;&gt;rustc guide&lt;/a&gt; or the &lt;a href=&quot;https://rust-lang.github.io/compiler-team&quot;&gt;compiler team documentation&lt;/a&gt;).&lt;/p&gt;
&lt;h1&gt;&lt;a href=&quot;#whats-next?&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-next?&quot;&gt;&lt;/a&gt;What's next?&lt;/h1&gt;
&lt;p&gt;More improvements to this diagnostic are planned and being worked on, so that it is applicable in
more cases, and has specialized messages for &lt;code&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt;, like below:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error[E0277]: future cannot be sent between threads safely
  --&amp;gt; src/main.rs:23:5
   |
5  | fn is_send&amp;lt;T: Send&amp;gt;(t: T) {
   |    -------    ---- required by this bound in `is_send`
...
23 |     is_send(foo());
   |     ^^^^^^^ future returned by `foo` is not `Send`
   |
   = help:  future is not `Send` as this value is used across an await
note: future does not implement `std::marker::Send` as this value is used across an await
  --&amp;gt; src/main.rs:15:3
   |
14 |   let g = x.lock().unwrap();
   |       - has type `std::sync::MutexGuard&amp;lt;'_, u32&amp;gt;`
15 |   baz().await;
   |   ^^^^^^^^^^^ await occurs here, with `g` maybe used later
16 | }
   | - `g` is later dropped here
&lt;/code&gt;&lt;/pre&gt;
</content>

        <author>
            <name>David Wood</name>
        </author>
    </entry>
    
    <entry>
        <title>Async Foundations Update: Time for polish!</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/10/07/AsyncAwait-WG-Focus-Issues.html" type="text/html" title="Async Foundations Update: Time for polish!" />
        <published>2019-10-07T00:00:00Z</published>
        <updated>2019-10-07T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/10/07/AsyncAwait-WG-Focus-Issues.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/10/07/AsyncAwait-WG-Focus-Issues.html">&lt;p&gt;As you've perhaps heard, recently the async-await feature &lt;a href=&quot;/2019/09/30/Async-await-hits-beta.html&quot;&gt;landed on
the Rust beta branch&lt;/a&gt;. This marks a big turning point in the
usability story for Async Rust. But there's still a lot of work to do.
As we mentioned in the main post, the focus for the &lt;a href=&quot;https://rust-lang.github.io/compiler-team/working-groups/async-await/&quot;&gt;Async Foundations
WG&lt;/a&gt; in the immediate term is going to be &lt;strong&gt;polish&lt;/strong&gt;, &lt;strong&gt;polish&lt;/strong&gt;
and (ahem) &lt;strong&gt;more polish&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;In particular, we want to take aim at a backlog of strange
diagnostics, suboptimal performance, and the occasional inexplicable
type-check failure. This is a shift: whereas before, we could have
laser focus on things that truly blocked stabilization, we've now got
a large set of bugs, often without a clear prioritization between
them. This requires us to mix up how the &lt;a href=&quot;https://rust-lang.github.io/compiler-team/working-groups/async-await/&quot;&gt;Async Foundations WG&lt;/a&gt; is
operating.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#announcing-focus-issues&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;announcing-focus-issues&quot;&gt;&lt;/a&gt;Announcing: focus issues&lt;/h3&gt;
&lt;p&gt;So how do you deal with a large pile of issues, all of which are
important but none of which are vital? One at a time, of course.&lt;/p&gt;
&lt;p&gt;The way we've chosen to organize this is something we call &lt;strong&gt;&lt;a href=&quot;https://rust-lang.github.io/compiler-team/working-groups/async-await/#how-to-get-involved&quot;&gt;focus
issues&lt;/a&gt;&lt;/strong&gt;. We're trying to keep a small number of issues tagged as
focus issues at any given time. As we close them, we'll pick new ones
to replace them. The number of these issues depends on mentoring
bandwidth and on how many people are hacking -- as a rule of thumb,
they should mostly all be assigned and actively progressing at any
given time.&lt;/p&gt;
&lt;p&gt;We also have a secondary set of issues called &lt;strong&gt;on deck issues&lt;/strong&gt;.
These are the candidates to become focus issues as focus issues are
completed. If you'd like us to consider fixing something sooner rather
than later, you can &lt;a href=&quot;https://rust-lang.github.io/compiler-team/working-groups/async-await/#nominating-issues&quot;&gt;add the &amp;quot;on deck&amp;quot; label yourself&lt;/a&gt;, along
with a bit of context explaining why you think this issue is more
important than the rest.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#how-you-can-help&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;how-you-can-help&quot;&gt;&lt;/a&gt;How you can help&lt;/h3&gt;
&lt;p&gt;You can help in two ways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Fix bugs!&lt;/strong&gt; If you'd like to take a shot at fixing a bug, try to
come to the &lt;a href=&quot;https://rust-lang.github.io/compiler-team/working-groups/async-await/#triage-meeting&quot;&gt;triage meeting&lt;/a&gt; or just show up in
&lt;a href=&quot;https://rust-lang.zulipchat.com/#narrow/stream/187312-wg-async-foundations&quot;&gt;&lt;code&gt;#wg-async-foundations&lt;/code&gt; on Zulip&lt;/a&gt;. Maybe we can find something
for you.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Nominate bugs!&lt;/strong&gt; If you've got a bug that is really
annoying you, feel free to &amp;quot;nominate it&amp;quot; by &lt;a href=&quot;https://rust-lang.github.io/compiler-team/working-groups/async-await/#nominating-issues&quot;&gt;following the
instructions here&lt;/a&gt;. This will help us to fix the things that
are bothering people the most.&lt;/li&gt;
&lt;/ul&gt;
</content>

        <author>
            <name>Niko Matsakis</name>
        </author>
    </entry>
    
    <entry>
        <title>Keeping Rust projects secure with cargo-audit 0.9: dependency trees, core advisories, unmaintained crates</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/10/03/Keeping-secure-with-cargo-audit-0.9.html" type="text/html" title="Keeping Rust projects secure with cargo-audit 0.9: dependency trees, core advisories, unmaintained crates" />
        <published>2019-10-03T00:00:00Z</published>
        <updated>2019-10-03T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/10/03/Keeping-secure-with-cargo-audit-0.9.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/10/03/Keeping-secure-with-cargo-audit-0.9.html">&lt;p&gt;&lt;a href=&quot;https://github.com/rustsec/cargo-audit&quot;&gt;cargo-audit&lt;/a&gt; is a command-line utility which inspects &lt;code&gt;Cargo.lock&lt;/code&gt; files and compares them against the &lt;a href=&quot;https://rustsec.org&quot;&gt;RustSec Advisory Database&lt;/a&gt;, a community database of security vulnerabilities maintained by the &lt;a href=&quot;https://github.com/rust-secure-code/wg&quot;&gt;Rust Secure Code Working Group&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can install &lt;code&gt;cargo-audit&lt;/code&gt; and run it against your project with the following commands:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cargo install cargo-audit
$ cargo audit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The 0.9 release of &lt;code&gt;cargo-audit&lt;/code&gt; includes a number of new features we hope make it more useful, including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UI improvements for understanding how vulnerabilities apply to your project&lt;/li&gt;
&lt;li&gt;Warnings for unmaintained crate dependencies (with an option to hard fail)&lt;/li&gt;
&lt;li&gt;Tracking of vulnerabilities in the Rust language itself&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;#ui-improvements-dependency-trees&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;ui-improvements-dependency-trees&quot;&gt;&lt;/a&gt;UI improvements: dependency trees&lt;/h2&gt;
&lt;p&gt;Previously, when &lt;code&gt;cargo-audit&lt;/code&gt; found a vulnerability in a project, it would display advisory information without any context as to how a particular vulnerable dependency is included in your project, making it difficult to determine what action needs to be taken to resolve the vulnerability.&lt;/p&gt;
&lt;p&gt;The latest release prints an inverse dependency tree (ala the excellent &lt;a href=&quot;https://github.com/sfackler/cargo-tree&quot;&gt;cargo-tree&lt;/a&gt; crate) for each advisory showing how a vulnerable dependency is included in your project:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RustSec/cargo-audit/a840f7b/screenshot.png&quot; alt=&quot;cargo audit with dependency tree&quot; /&gt;&lt;/p&gt;
&lt;p&gt;In future versions of &lt;code&gt;cargo-audit&lt;/code&gt; we &lt;a href=&quot;https://github.com/RustSec/cargo-audit/issues/23&quot;&gt;hope to add a &lt;code&gt;cargo audit fix&lt;/code&gt; command&lt;/a&gt; ala &lt;code&gt;npm audit fix&lt;/code&gt; which can either automatically update the necessary dependencies or provide instructions on how to do so. If that feature interests you and you'd like to contribute, &lt;a href=&quot;https://github.com/RustSec/cargo-audit/issues/23&quot;&gt;we're looking for help&lt;/a&gt;!&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#new-feature-unmaintained-crate-warnings&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;new-feature-unmaintained-crate-warnings&quot;&gt;&lt;/a&gt;New feature: unmaintained crate warnings&lt;/h2&gt;
&lt;p&gt;This release added the notion of &lt;a href=&quot;https://github.com/RustSec/rustsec-crate/pull/75&quot;&gt;informational advisories&lt;/a&gt; - advisories which don't directly represent a security vulnerability, but may contain potentially security-relevant information. The primary intended use for this feature is &lt;a href=&quot;https://github.com/RustSec/advisory-db/issues/173&quot;&gt;providing warnings for unmaintained crates&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A recent study, &lt;a href=&quot;https://www.usenix.org/system/files/sec19-zimmermann.pdf&quot;&gt;Small World with High Risks: A Study of Security Threats in the npm Ecosystem&lt;/a&gt;, showed that unmaintained npm packages pose a high risk to that ecosystem:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Our results provide evidence that npm suffers from single points of failure and that unmaintained packages threaten large code bases&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Rust is in a similar boat with some high profile crates, &lt;a href=&quot;https://github.com/Stebalien/term/issues/93&quot;&gt;such as the &lt;code&gt;term&lt;/code&gt; crate&lt;/a&gt; (downloaded 8,000 times a day), are unmaintained. By &lt;a href=&quot;https://github.com/RustSec/advisory-db/issues/173&quot;&gt;tracking information about unmaintained crates in the RustSec Advisory Database&lt;/a&gt;, we hope to improve visibility on these crates, either by helping people discover &amp;quot;successor&amp;quot; crates they should switch to, or putting potential volunteer maintainers in touch with authors interested in handing crates off. When those handoffs happen, we can mark unmaintained crate advisories as obsolete (while still giving interested security researchers a list of crates to keep an eye on for potential &lt;a href=&quot;https://blog.npmjs.org/post/180565383195/details-about-the-event-stream-incident&quot;&gt;software supply chain attacks&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;If you have an unmaintained crate you'd like us to create an advisory for, or know of a third party unmaintained crate and would like to provide information about potential alternatives, please &lt;a href=&quot;https://github.com/RustSec/advisory-db/issues/173&quot;&gt;leave a comment in the RustSec/advisory-db#173 GitHub issue&lt;/a&gt; and we can file an advisory for it.&lt;/p&gt;
&lt;p&gt;For now, unmaintained crates are surfaced as warnings, with some brief information available about each one and a link to click to read more. If you'd like for unmaintained crate advisories to be considered errors (so &lt;code&gt;cargo-audit&lt;/code&gt; exits with a non-zero status for e.g. CI purposes), run:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cargo audit -D
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or if you prefer to be more explicit:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cargo audit --deny-warnings
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href=&quot;#tracking-rust-language-vulnerabilities&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;tracking-rust-language-vulnerabilities&quot;&gt;&lt;/a&gt;Tracking Rust language vulnerabilities&lt;/h2&gt;
&lt;p&gt;Previously the &lt;a href=&quot;https://rustsec.org&quot;&gt;RustSec Advisory Database&lt;/a&gt; only tracked information about vulnerable crates published through &lt;a href=&quot;https://crates.io&quot;&gt;crates.io&lt;/a&gt;. Starting with this release, however, we are also indexing advisories for vulnerabilities in the Rust language's core ecosystem components, including &lt;code&gt;std&lt;/code&gt;, &lt;code&gt;cargo&lt;/code&gt;, and &lt;code&gt;rustdoc&lt;/code&gt;. We've now indexed the following vulnerabilities:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://rustsec.org/advisories/CVE-2018-1000622.html&quot;&gt;CVE-2018-1000622: rustdoc: Uncontrolled search path element vulnerability in rustdoc plugins&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://rustsec.org/advisories/CVE-2018-1000657.html&quot;&gt;CVE-2018-1000657: std: Buffer overflow vulnenrability in &lt;code&gt;VecDeque::reserve()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://rustsec.org/advisories/CVE-2018-1000810.html&quot;&gt;CVE-2018-1000810: std: Buffer overflow vulnerability in &lt;code&gt;str::repeat()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://rustsec.org/advisories/CVE-2019-12083.html&quot;&gt;CVE-2019-12083: std: Memory safety vulnerabilities arising from &lt;code&gt;Error::type_id&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://rustsec.org/advisories/CVE-2019-16760.html&quot;&gt;CVE-2019-16760: cargo: Cargo prior to Rust 1.26.0 may download the wrong dependency&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We are &lt;a href=&quot;https://github.com/RustSec/cargo-audit/issues/140&quot;&gt;interested in potentially surfacing information about these advisories via cargo-audit&lt;/a&gt;, e.g. optionally detecting if the currently active Rust toolchain is vulnerable. If that interests you, we're also looking for help on this issue!&lt;/p&gt;
&lt;p&gt;Thanks for reading, and we hope you enjoy &lt;code&gt;cargo-audit&lt;/code&gt; 0.9!&lt;/p&gt;
</content>

        <author>
            <name>Tony Arcieri</name>
        </author>
    </entry>
    
    <entry>
        <title>Welcome to the Inside Rust blog!</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/09/25/Welcome.html" type="text/html" title="Welcome to the Inside Rust blog!" />
        <published>2019-09-25T00:00:00Z</published>
        <updated>2019-09-25T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/09/25/Welcome.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/09/25/Welcome.html">&lt;p&gt;Welcome to the inaugural post of the &lt;strong&gt;Inside Rust&lt;/strong&gt; blog! This is a
new blog where the various Rust teams and working groups can post
updates about new developments. It's a great place to watch if you're
interested in following along with Rust development -- and a
particularly great place to watch if you're interested in contributing
to Rust. Expect to see updates on new projects, calls for help, design
notes, and other similar items. Thanks for reading!&lt;/p&gt;
</content>

        <author>
            <name>Niko Matsakis</name>
        </author>
    </entry>
    
</feed>
